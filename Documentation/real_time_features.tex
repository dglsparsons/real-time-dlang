In order to supply support for programming real-time systems, we must first 
consider the characteristics of a real-time system. This section aims to outline
any necessary primites for a programming language, explaining why they are 
necessary. 

\subsection{Threads and Interprocess Communication}
Real-time systems are inherrently parallel. They are concerned heavily with 
the notion of timing for many different components across a system. 
The ability to schedule these components in isolation  through the medium 
of threads therefore provides a valuable tool in reducing the complexity in 
constructing the system, and additionally increases the readability of the 
final system \cite{BURNS +WELLING p132}.

\subsection{Priority Scheduling}
In addition to the creation and isolation of processes through the use of 
threads, it is a requirement of real-time systems to provide control over 
their scheduling. Threads may be either language controlled, or operating
system controlled. If the first is true, then it is necessary to provide 
language functionality enabling the threads to be scheduled on a 
priority based method. If the latter is true, then the language needs 
support for interacting with the operating system to adjust the scheduler. 

\subsection{Priority Inversion}
When using shared resources in a priority based system, it is possible for 
a high priority task to become blocked from making progress, due to a low
priority task holding onto a resource. In addition, the low priority task 
may become blocked by a task with priority between the high priority task, 
and the low priority task. In this instance, the high priority task is 
effectively running at the lowest priority: it has to wait for all other 
tasks to complete before it can progress. 
For a real-time system, it is a requirement that this condition does not 
occur. As a result, a priority inheritance, or piroity ceiling protocol 
must therefore be implemented, raising the priority of any task blocking
resources. 

\subsection{Monotonic Clocks and Absolute Sleep}
In general programming, when a worker thread has no computation to be 
performing, a call is made to a sleep method. This will cause the thread
to hand over any computation time for a defined amount of time. In a 
real-time system however, we often require fine-grained control of exactly
when a thread will awaken. The typical approach involving a relative sleep 
time can be imprecise due to preemption. In order to achieve a predictable 
sleep function, as required in a real time system, it is therefore necessary 
to have the ability to wait until an absolute time. Further complication 
occurs with the definition of time: many implementations of time are subject 
to phenomena such as daylights savings time, or leap seconds. 
In order to counteract these, a Monotonic clock must be used. This ticks at a 
predifined costant rate, giving predictable behaviour. 

\subsection{Asynchronous Transfer of Control}
Asynchronous Transfer of Control entails the ability to define a section of code, 
that at any moment in time may be externally interrupted. This can be used for a 
wide range of features, such as changes in mode of operation, recovery from a 
rogue procedure, or scheduling using partial computations.
