As mentioned in the introduction, the D programming language has many 
characteristics that lend it nicely to the development of real-time systems.
These are outlined in further detail in this section. 
However, D also has certain features that are less desirable for a real-time 
system, such as the use of a garbage collector. These less desirable features 
are also detailed in this section.


\subsection{High and Low-Level}
% Aims to achieve everything that is possible with other languages such as C++
% Contains high level abstractions
The D programming language is primarily inspired by C++, aiming to be a ``C++ done
right'' 
\cite{qznc-tutorial}. This explains the 
power that the language possesses: D is primarily a high level language, with
a large number of abstractions that aid in the speed an ease of development. 
However, D still maintains low level capabilities: the language still has access 
to inline assembler, system calls, interrupts, and low level I/O in addition to 
being a compiled language.
\par\bigskip\noindent
The flexibility of D is one of the largest advantages. It ``allows its user to tap 
into a wide range of programming techniques, without throwing too many 
idiosyncrasies in the way''
\cite{ddili-book}, 
while simultaneously generating code that can be aggressively optimized by the
compiler 
\cite{dlang-overview}. D maintains a readable syntax, and 
user-friendly approach to development, making it a powerful and highly capable 
language.

\subsection{Memory Safe Programming}
% Concept of memory safe programming that D supports.
An area of particular interest to Real Time systems is the notion of memory 
safe programming. In addition to providing powerful inbuilt types such as arrays 
in D, the D compiler also implements range checking and numerous other 
safety checks on compilation, preventing any undefined behaviour from occurring.
Additional safety features are also provided in the SafeD subset of the language
\cite{safe-d}. The SafeD subset will only allow functions to perform 
operations that are deemed as either safe or trusted, preventing any 
potential corruption of memory. Examples of unsafe functions could include the 
manual manipulation of pointers, or the use of unsafe types. A major difference 
with regards to other languages is that D provides sufficient power so that many complex 
operations can be performed and used, while still remaining completely safe.

\subsection{Concurrency}
%Message passing
D is often referred to as a language that implements the message passing model 
of concurrency, rather than the more standard Lock and Mutex approach 
\cite{ddili-book}. D's message passing API 
allows asynchronous messages to be transferred between threads of control using 
message boxes. This allows a high-level of abstraction and provides an 
interface that is simplistic to use. However, it is also misleading: the underlying 
model of D uses the more typical lock and mutex approach 
\cite{dlang-github-mutex}, 
with the message passing interface simply built on top of this 
\cite{dlang-github-concurrency}. 
As such, when developing in D, the programmer has the option to choose between 
the higher level message passing interface or the lower level lock and mutex 
approach. It is even true that the two can both be used, taking a mixed approach. 
\par\bigskip\noindent
D also has an interesting approach to sharing memory between threads. In D 
global variables are not shared between threads of control, as they are in 
other languages. Instead, each thread has a local copy of the global variable. 
This is a concept that is known as Thread Local Storage (TLS) 
\cite{migrate-to-shared}. 
If resources are to be shared between different threads, D provides a way of 
achieving this: the \texttt{shared} and \texttt{\_\_gshared} keywords. In addition, 
\texttt{immutable} variables are shared by default. 
\par\bigskip\noindent
The core runtime for D provides an additional interesting feature: an atomicop 
library 
\cite{core-atomic}. 
This provides a mechanism for some degree of sharing to be performed without the 
need for locks, allowing many operations to be performed indivisibly.


\subsection{Garbage Collector}
%GC
One significant problem with developing a real-time system in D is the need to 
overcome D's garbage collector. The current implementation of the garbage 
collector is a `stop the world' approach: when garbage collection is occurring, 
all different threads are halted from making progress 
\cite{dlang-garbage}. This causes problems with 
real-time systems. A real-time system must be able to guarantee a maximum response 
time on any operation performed, predictable behaviour is therefore fundamental to this. 
With a stop the world garbage collector, such behaviour cannot be guaranteed. 
\par\bigskip\noindent
One possible solution to this problem is to disable the garbage collector for 
real time applications. This is possible to do by marking functions \texttt{@nogc}, 
or by calling \texttt{GC.disable()}. However, this is not without drawbacks: 
many of D's higher level features and libraries use garbage collection. 
Due to the amount of further work required, tackling the issue of the garbage collector is outside the scope of this 
article.

\subsection{Additional Interesting Features}
% Idea of built in tests, contract programming, debugging, error handling
Another unique feature of D is the ability to build unit tests into a 
program without the need for external libraries: D provides support for 
unittesting as a language feature. 
\par\bigskip\noindent
In addition, D provides a Java style model for Exceptions and Errors, enabling 
a much simpler error handling system than the C style ERRNOs 
\cite{ddili-book}. 
