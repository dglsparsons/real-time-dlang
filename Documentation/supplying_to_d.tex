% Article writing on how Real Time features are provided to Dlang

In the previous chapter, we discussed the characteristics a real-time 
systems programming language would need to provide in order to enable the 
development of a real-time system. The aim of this project has been primarily to 
provide these primitives to the D programming language, and hence any discussion, 
design decisions and the implementation of these features is discussed in this 
section. 

\subsection{Threads and Interprocess Communication}
D, being a C/C++ style language, provides support for the creation and use of 
threads. Threads in D follow a Java style approach: Thread is a class, 
allowing subclasses to be derived and methods to be overridden. The default 
class method will allow a function to be passed by reference and executed. 
This is seen in the example below, taken from the D website. 
\cite{http://dlang.org/phobos/core_thread.html}: 
\begin{lstlisting}
class DerivedThread : Thread
{
    this()
    {
        super(&run);
    }
    private:
    void run()
    {
        // Derived thread running.
    }
}

void threadFunc()
{
    // Composed thread running.
}

// create and start instances of each type
auto derived = new DerivedThread().start();
auto composed = new Thread(&threadFunc).start();
\end{lstlisting}
We can therefore see that the primitive of Threads, and interprocess communication 
is already provided by D. However, the implementation is of interest: D 
provides an agnostic approach to operating systems, supporting Windows, FreeBSD, 
OSX and Linux. 
In order to provide support for this wide range of operating systems, the Thread 
class contains operating system specific code, mapping down a standard interface 
onto various underlying implementations 
\cite{https://github.com/D-Programming-Language/druntime/blob/master/src/core/thread.d}. 
We are interested only in operating systems 
that support real-time applications, and as such all additions made to D with 
regards to real-time applications are specifically targeting POSIX compliant 
operating systems. 
\par\bigskip\noindent
It is worth noting that the underlying operating system may not be fully
real-time compliant, even if it is POSIX compliant. Real-time patches to the 
Linux kernel exist 
\cite{https://rt.wiki.kernel.org/index.php/Main_Page}, enabling a greater 
guarantee over the responsiveness. Special care may also be required when 
developing such a system 
\cite {https://rt.wiki.kernel.org/index.php/HOWTO:_Build_an_RT-application}. 

\subsection{Monotonic Clocks and Absolute Sleep}
As mentioned in the previous chapter, it is a necessary feature of a real-time 
systems programming language to be able to sleep until an absolute time, rather 
than a relative time. In addition, this sleep must use a monotonic clock in order 
to remove any subjection from clock-drift, or time-zone changes. D has support 
for a monotonic clock as part of the core libraries 
\cite{http://dlang.org/phobos/core_time.html}. We can access this using 
\texttt{MonoTime}, but unfortunately there is no ability to sleep until an 
absolute time. Using D's ability to interact with C libraries, it is possible 
to leverage Glibc's ability to perform this operation: the C function 
clock\textunderscore{}nanosleep allows an absolute time to be specified.
\cite{http://man7.org/linux/man-pages/man2/clock_nanosleep.2.html}
A wrapper function has been provided as part of a real-time library, delayUntil. 
This function accepts the D type MonoTime as an input, convert it to the C 
equivalent, and calls the C function clock\textunderscore{}nanosleep, allowing an absolute delay.
The code is displayed below: 
\begin{lstlisting}
void delayUntil(MonoTime timeIn)
{
    import core.sys.linux.time; 
    import core.time : Duration, timespec; 
    Duration dur = timeIn - MonoTime(0) ;
    long secs, nansecs; 
    dur.split!("seconds", "nsecs")(secs, nansecs); 
    timespec sleep_time = timespec(secs, nansecs); 
    if (clock_nanosleep(CLOCK_MONOTONIC, 
    TIMER_ABSTIME, &sleep_time, null))
    throw new Exception("Failed to sleep as expected!"); 
}
\end{lstlisting}
This allows a simplistic use from a real-time application. A relative sleep can 
be performed in the following manner: 
\begin{lstlisting}
void main()
{
    auto time = MonoTime.currTime(); 
    time += 3.seconds; 
    delay_until(time);
}
\end{lstlisting}
As such, the D programming language can easily provide the ability to sleep 
until an absolute time. In order to easily use this functionality, a 
wrapper has been provided.

\subsection{Priority Scheduling}
The ability to correctly schedule tasks or threads based on their priority is of 
critical importance to a real-time system. As previously discussed within this 
section, D provides the isolation mechanic of a Thread, easily allowing the 
separation of concern. Additionally, the Thread class contains the parameter, 
priority, that can be used to set or get a threads priority
\cite{http://dlang.org/phobos/core_thread.html}. 
However, in order for priority based scheduling to be used, this alone is not 
enough: the scheduler must be changed to function in a priority based manner. 
It was previously identified that D's threads provide a mapping onto an operating  
system thread, and hence it is the operating system scheduler that has to be set.  
No support exists within the D standard libraries to interact with the scheduler 
however, so this support has to be supplied. 
This was achieved once again through interaction with Glibc: the function 
sched\textunderscore{}setscheduler allows the operating system scheduler to 
be set to either SCHED\textunderscore{}FIFO or SCHED\textunderscore{}RR for 
this process
\cite{http://linux.die.net/man/2/sched_setscheduler}. 
As with the delayUntil function, a wrapper has been added around the C function,
providing a simpler interface: 
\begin{lstlisting}[language=C++]
public import core.sys.posix.sched 
                : SCHED_FIFO, SCHED_OTHER, SCHED_RR; 

void setScheduler(int scheduler_type, int scheduler_priority)
{
    import core.sys.posix.sched 
                : sched_param, sched_setscheduler; 

    sched_param sp = { 
        sched_priority: scheduler_priority 
    }; 

    int ret = sched_setscheduler(0, scheduler_type, &sp); 
    if (ret == -1) {
        throw new Exception("scheduler did not properly set");
    }
}
\end{lstlisting}
This can then be called in the following manner: 
\begin{lstlisting}
void main()
{
    setScheduler(SCHED_FIFO, 0); 
}
\end{lstlisting}
The ability to set the scheduler to use a priority based method, combined with 
D languages previously present ability to set the priority of a thread therefore 
enables a priority based scheduling approach to be used.  

\subsection{Bounded Priority Inversion}
In D, Mutexes follow a similar approach to Threads: the languages'
implementation provides a wrapper around operating system calls, this 
enables operating system independent code to be written simply. However, D has no 
inherent ability to provide priority inversion handling protocols. 
However, these protocols are already provided for POSIX compliant Mutexes 
\cite{http://linux.die.net/man/3/pthread_mutexattr_setprotocol}. On a POSIX 
compliant operating system D will use this mutex type but not set the protocol. 
By interacting with Glibc, we can therefore inherit from the default mutex class, 
and provide a constructor that sets this property.
A mutex created like this may then be initialised in the following manner: 
\begin{lstlisting}
auto a = new RTMutex(PRIORITY_INHERIT);
\end{lstlisting}
Additionally, support is needed to set and receive the priority ceiling 
associated with the mutex. This is achieved in a similar manner, additional 
functions can be added providing a wrapper around the C functions 
pthread\textunderscore{}mutex\textunderscore{}getprioceiling and 
pthread\textunderscore{}mutex\textunderscore{}setprioceiling
in the following manner 
\cite{http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_getprioceiling.html}:
\begin{lstlisting}
final @property int ceiling()
{
    int ceiling; 
    if(pthread_mutex_getprioceiling(&m_hndl, &ceiling))
    throw new SyncError("Unable to fetch the priority 
                    ceiling for the associated Mutex"); 
    return ceiling; 
}
\end{lstlisting}
This allows the priority ceiling to be set or get as if it were a property of 
the class. Allowing a very idiomatic and readable interaction: 
\begin{lstlisting}
auto a = new RTMutex(PRIORITY_CEILING); 
a.ceiling = 50; 
writeln("priority ceiling of a is: ", a.ceiling); 
\end{lstlisting}
Therefore, on a POSIX compliant operating system, the ability to interact with 
existing C libraries enables D to provide a subclass of the languages default 
Mutex class. This subclass is capable of providing either the priority ceiling 
protocol, or the priority inheritance protocol. Wrappers around the C functions 
enable this to be used in an intuitive manner. 

\subsection{Asynchronous Transfer of Control}
