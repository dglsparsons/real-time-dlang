% Literature Review for my project. 

% Word Count Guide - 3000 words

% One or more review chapters, describing the research I did at the beginning
% of the project period. 

%Demonstrate that they have acquired specialisation in a particular part of the subject area, 
%including enhanced or new technical skills that build on taught theory. 
%Examined in the overall project report. 


In this chapter, the literature surrounding real-time systems shall be reviewed. 
Each of the various programming language constructs that are to be provided in 
order to program a real-time system will be examined. 

\section{Features of a Real-Time System}

A significant amount of research has gone into the addition of features to 
real-time languages. Through the use of these, a multi-processor system can be 
programmed in such a way that all tasks in the system will operate within a finite 
and predictable timespan. Furthermore, these allow precise timings to be used, 
ensuring that deadlines within a system can be reliably met. 
Burns and Wellings 
provide a detailed overview of development for real-time systems in their book, 
\emph{Real Time Systems and Programming Languages} \cite{real-time-systems}. 
This provides a detailed and complete set of information, informing the reader 
of the base requirements of a real-time system, the implementation of 
real-time systems in various programming languages, along with any theory, 
such as scheduling theory, surrounding the field. In providing a detailed overview 
of the real-time programming concepts required in a programming language, this 
book provides a detailed overview of what implementation is required in my project.

\subsection{Concurrent Programming}
% Dijkstra
Ever since Dijkstra introduced the concepts of mutual exclusion, 
processes, semaphores, deadlock, preconditions and guards in his 1968 seminal paper, 
\emph{Cooperating Sequential Processes}, 
concurrent programming has seen an explosion in popularity 
\cite{Dijkstra}. 
The aspects of synchronisation and concurrency have become fundamental issues 
of computing science, with a wide variety of research exploring, and attempting to 
maximise the field's potential, as well as providing mechanisms that aid the development 
of concurrent programs \cite{Sutter:2005:SCR:1095408.1095421,Hansen:1972:SM:361454.361473}. 
The most notable example of which is perhaps the introduction of monitors by Tony Hoare, 
these enable a simplification of logic and are used in the introduction of many abstractions 
such as Ada's protected objects \cite{Hoare:1974:MOS:355620.361161}. 
\par\bigskip\noindent
% Then apply the concurrent aspect of this to a real-time system! 
Real-time systems benefit greatly from parallelism. Inherently, they are concerned with 
the notion of timing and scheduling many different components across a system. 
The ability to schedule these components concurrently and in isolation 
therefore provides a valuable tool. Concurrent programming serves to not only 
enable complex systems to be more simply developed, but provides much more 
readable, modular systems. Furthermore, concurrency reduces the complexity of 
scheduling these systems \cite{real-time-systems}. 
It is therefore a requirement of a real-time systems 
programming language to provide support for an abstraction into isolating 
concurrent events and their control into separate entities. 
In Java and C with real-time POSIX, this concurrency mechanism is provided by 
threads or processes. In Ada this mechanism is provided by Tasks 
\cite[p251]{gehani1989concurrent}.

\subsection{Priority Scheduling}
%Some theory on priority based scheduling.
In addition to the separation of concerns in real-time systems through 
concurrent programming, the ability to schedule system components in a predictable 
manner is of interest. 
Much research has gone into the development of many different fair scheduling 
algorithms, such as those of the Linux scheduler \cite{6043273,7280991}. However, 
these do not provide guarantees on the schedulers behaviour, and tasks with short 
deadlines may have to wait for extended periods of time. Instead, real-time systems 
do not care about the scheduler implementing a fair algorithm. Instead, 
scheduling policies have been developed that focus on ensuring short deadline tasks 
are executed in preference to others, so they still meet their deadlines. 
% Apply it to real-time systems
\par\bigskip\noindent
Many algorithms exist that enable real-time systems to be scheduled, such 
as earliest deadline first (EDF) Least Laxity First (LLF), or Fixed Priority 
scheduling
\cite{real-time-systems}. 
However, each policy requires separate computational analysis in order to determine 
whether the system will meet all its deadlines.
The field of schedulability analysis is based around this, with research 
aiming to provide tests to determine if a system will behave as expected
\cite{4815215,burns-sched-analysis}.
While Burns posits a test for the schedulability of EDF systems, such systems are 
more difficult to implement in practice: priorities are dynamic, and may change 
at any time. Furthermore, not all tasks may have a deadline, making 
them difficult to incorporate into such a system.
As a result, the most commonly used scheme is fixed-priority scheduling. 
\par\bigskip\noindent
It is therefore a requirement of a real-time systems programming language to 
provide support for a priority based scheduling algorithm or allowing the 
scheduler to be customised. 

\subsection{Bounded Priority Inversion}
% Talk about the priority inversion problem. Introduce it. 
% Talk about existing solutions to the priority inversion problem - Priority
% Ceiling protocol, and the Priority Inheritance protocol. % Show the research
% that they come from.
Concurrent components of a system are rarely truly isolated from each other, often 
requiring some shared information or data between different parts of the system. 
Using priority based scheduling, it is possible for 
a high priority task to become blocked from making progress due to a low
priority task holding a resource. Additionally, the low priority task may be 
preempted and prevented from making progress. In this instance, the high priority task is 
effectively running at the lowest priority of the system: it has to wait for all other 
tasks to complete before it can progress. This is a well studied phenomenon known 
as priority inversion 
\cite{real-time-systems}. 
\par\bigskip\noindent
In order to provide a reliable response in a priority based system, it is 
therefore necessary that priority inversion is bounded.
Two main protocols exist that solve this problem: the priority inheritance protocol 
and the priority ceiling protocol. 
In \cite{57058}, a priority inheritance protocol is defined along with the priority 
ceiling protocol. 
The priority inheritance protocol works by raising the priority of a task 
holding a resource to the priority of any task that attempts to gain access 
to the resource.
Contrastingly, the priority ceiling protocol raises the priority of the task as 
it first accesses 
the resource to the highest priority of any task that may access the resource. 
Each protocol has its own respective 
strengths and weaknesses, but enable reliable behaviour of the system 
\cite{mall2009real}.
It is therefore a requirement of a real-time systems programming language 
that the underlying data sharing system is not subject to unbounded priority 
inversion: the ability to specify the use of either the priority inheritance 
protocol or the priority ceiling protocol is a necessary feature.  

\subsection{Monotonic Clocks and Absolute Sleep}
% Talk about studies of clocks, and drift for real-time systems. 
Up to this point, it has been assumed that the real-time systems are able to 
interact with precise timing requirements down to a very fine degree of accuracy.
In practice, this is not always the case, in particular with the use of 
distributed systems. There is a large field of research surrounding the 
synchronisation of multiple devices, with algorithms such as Christian's for 
synchronising these systems \cite{37958}. However, the crucial aspect is the 
access of a monotonic clock: a clock that ticks at a constant rate, and does not 
vary the way a calendar clock does. Baker and Pazy in their 1991 paper, \emph{
Real-time Features for Ada 9X} cite the need for high precision, non-changing 
clocks as a language feature \cite{160371}. 
\par\bigskip\noindent
It is therefore clear that it is a requirement of a real-time systems programming 
language to provide access to monotonic clocks, so that high precision timing 
requirements can be met. 
\par\bigskip\noindent
Additionally, the ability to awaken threads at times stated by a clock is a 
requirement of real-time systems. A typical \texttt{sleep} function will cause 
the calling thread to hand over any computation resources for a defined period of time. 
In a real-time system, the timing that the thread awakens must be precise. 
The typical approach involves the use of a relative sleep time, and therefore can 
be imprecise due to preemption \cite{real-time-systems}: calculating the sleep time
and then being preempted before the call to \textt{sleep} will lead to incorrect 
timings. Therefore, in order to achieve a predictable 
sleep function as required in a real-time system, it is necessary 
to have the ability to wait until an absolute time using a high precision 
system clock, such as a monotonic clock.

\subsection{Asynchronous Transfer of Control}
% Introduction to ATC 
Asynchronous Transfer of Control (ATC) is a controversial topic with regards to its 
implementation in many languages, yet it is deemed a useful, if not necessary 
feature of a real-time system \cite{atc-article}. 
ATC is the transfer 
of control within a thread, that has been triggered by an external event or thread. 
Its effect may be instantaneous, or deferred until a safe section in the code has 
been reached. In addition, sections of code susceptible to ATC may be nested, causing a 
complex problem in terms of semantics, methodology, and implementation. 
However, the use of ATC extends to many purposes such as low latency responses to events, timing 
out a thread of computation, or terminating threads, making it an invaluable feature. 
% Have 2-3 articles on the different approaches to ATC within real-time systems
% programming languages
The various methods of implementing Asynchronous Transfer of Control have been well 
studied, with implementations existing in both Java and Ada. Brosgol and Wellings 
detail the differences between the Ada and Real-time Java implementations, with 
Java favoring a class based approach to the protocol, where Ada instead provides 
an explicit language syntax \cite{atc-article}. Both solutions favor safety of 
the system, and do not necessarily provide immediate cancellation. In \cite{Brosgol:2002:ATC}, 
Brosgol details that there are two alternative implementations for ATC. The first 
concept is aborting a thread. This contains a statement that will abort a thread, 
and there is a notion of an abort-deferred region. This method avoids complex rules 
that come with ATC, and avoids more complex rules such as propagation. However, 
it has an additional overhead of thread management, and thread dependencies. 
The second approach discussed is an exception based model. In this, ATC is 
captured by allowing a thread to ``arbitrarily throw an exception at a target thread``.
This method avoids the overhead of additional thread creation, however, it requires 
additional safety to prevent exceptions from thrown when the target thread is not 
ready to handle it. 
\par\bigskip\noindent
It is therefore possible to determine that Asynchronous Transfer of Control is a 
fundamental notion for a real-time system. The ability to time out a computation, 
or terminate a thread during processing is very useful. However, the implementation 
of this principal requires careful consideration. In order to maintain a safe 
system, Threads may not be terminated at any moment in time, they must have the 
ability to defer interrupts when desired. Additionally, there are two main methods 
of implementation, either a thread cancellation based model, or an asynchronous 
exception model. While the thread model has additional overhead due to the creation 
of new threads, the exception based approach has additional complexity requiring 
the ability to safely defer throwing the exception. 

\section{Abstractions}

Combined with the fundamental ability for a programming language to provide support 
for real-time systems programming principals, the language must provide abstractions 
for many principles in order to avoid unnecessary overcomplication, and hence to 
ease development.

\subsection{Periodic Tasks}
Ada and Real-time Java provide mechanisms for easily creating a periodic task. 
In Java,

\subsection{Sporadic, Aperiodic Tasks}
\subsection{Jitter}

\section{Language Design}
\subsection{Interprocess Communication and Synchronisation}
\subsection{Atomic actions}
\subsection{Exception and Error Handling}
\subsection{Low Level Capabilities}

\section{Alternative Languages}
\subsection{Real-Time Java}
\subsection{Ada}
\subsection{C with Real-Time POSIX}
