% The Design and Implementation Section - plenty to discuss in here - how 
% each different part of the system has been designed and implemented, as well
% as what the original design aims were. 

%Formulate a moderate sized problem, to select and justify an appropriate approach, 
%and to follow the approach systematically. 
%Examined in the design/implementation chapters of the project. 

%Recognise alternatives, selecting and justifying the approach taken at each 
%point in the report, identifying parts of the project area that are feasible 
%within the time (etc) constraints of the project. Examined in the 
%design/implementation chapters of the project. 

%Appreciate the latent issues of the subject area (for example, in software 
%engineering they might meet and tackle such as emergent requirements, design 
%flaws, equipment/application problems). Examined in the project 
%design/implementation and evaluation chapters. 


% Word Count Estimate - 2500 Words

% \section{Design Aims} -- MAYBE DON'T NEED THIS BIT AS THE REQUIREMENTS ARE TO
% BE FORMULATED FROM THE LIT REVIEW SECTION 

% Using D Way that D works - hooks into C standard libraries in order to 
% provide support for things. 

% Targeting POSIX operating Systems - real time features, not many other OS 
% can do this. 

% Ability to target different compilers, not require custom runtimes. 
% GIVES THE ESSENTIAL - Program written with no knowledge of the Real-time
% systems additions I am creating will not be effected. This means support can 
% be added in through importing a library. 
In previous chapters,
existing real-time system programming languages have been examined in order to
define a set of required functionality. From this, a set of project requirements 
was determined. 
This chapter aims to describe the implementation of these requirements into the D
programming language, highlighting the completed implementations and any design 
decisions made along the way. 
Each of the functional requirements of the project the potential
implementations are discussed. In this discussion, any design 
decisions that have been made will be detailed. Furthermore, this chapter will 
detail the completed implementation of each component. 

\section{Method of Provision}
% Library vs modified runtime ? 
For the end goal of this project to be usable, various methods for its delivery 
were considered. There are two significant alternatives. If no compiler, or 
core runtime features of the language need to be altered in order to provide the 
desired functionality then the project may be packaged as an external library. 
This is the most desirable end goal, hence the addition of requirement 8, as it 
prevents the need to provide and maintain a custom complier and runtime and enables 
exsiting D users to simply add-in the library as needed. 
Failing this, a modified runtime and/or compiler must be provided. This would 
enable the development of real-time systems, however, the modified system would 
require maintenance to keep it up to date with the core set of D functionality. 

\section{Requirement 1: Threads and Interprocess Communication}
D, being a C/C++ style language, provides support for the creation and use of 
threads. Threads in D follow a Java style approach: \texttt{Thread} is a class, 
allowing subclasses to be derived and methods to be overridden. The default 
class method will allow a function to be passed by reference and executed. 
These features can be seen in the example below, taken from the D website
\cite{core-thread}: 
\begin{lstlisting}
import core.Thread; 

class DerivedThread : Thread
{
    this()
    {
        super(&run);
    }
    private:
    void run()
    {
        // Derived thread running.
    }
}

void threadFunc()
{
    // Composed thread running.
}

// create and start instances of each type
void main()
{
    auto derived = new DerivedThread();
    auto composed = new Thread(&threadFunc);
    derived.start; 
    composed.start;
}
\end{lstlisting}
We can therefore see that D already provides 
concurrent control of system components, along with mechanisms for 
interprocess communication. However, the implementation is of interest: D 
provides an agnostic approach to the underlying operating system, supporting 
Windows, FreeBSD, OSX, Linux and Solaris. 
In order to provide support for this wide range of operating systems, the 
\texttt{Thread}
class contains operating system specific code, mapping down a standard interface 
onto various underlying implementations 
\cite{github-core-thread}. 
We are interested only in operating systems capable of meeting tight timing 
requirements in any calls to the kernel, and context switching.
As such, all additions made to D with regards to real-time applications are 
specifically targeted at POSIX compliant 
operating systems, in particular those with real-time extensions. 
\par\bigskip\noindent
It is worth noting that the underlying operating may require patching in order 
to be fully viable for a real-time system: system may not be fully
real-time compliant even if it is POSIX compliant. Because of this, real-time patches 
to the Linux kernel exist \cite{rt-wiki}. These enabling a greater 
guarantee over the timeliness of the kernel. 
Furthermore, special care must also be taken when developing such a system,
selecting appropriate hardware and programming the system in a manner appreciative 
of the underlying hardware \cite{rt-wiki-how-to}.

\section{Requirement 2: Priority Based Scheduling}
The ability to correctly schedule tasks or threads based on their priority is of 
critical importance to a real-time system. As previously discussed D provides 
concurrency through operating system Threads, encapsulated in the
\texttt{Thread} class. Additionally, the \texttt{Thread} class contains the 
parameter, \texttt{priority}. This parameter can be used to set or get a thread's 
priority \cite{core-thread}. 
However, in order for priority based scheduling to be used, this alone is not 
enough: the scheduler must be changed to function in a priority based manner. 
It was previously identified that D's threads provide a mapping onto an operating  
system thread, and hence it is the operating system scheduler that has to be set.  
However, no support exists within D's standard libraries to interact with the
scheduler. 
Therefore, this support has to be supplied. 
This can be achieved through interaction with C standard libraries, such as GlibC. 
The function sched\textunderscore{}setscheduler allows the operating system 
scheduler to be set to either SCHED\textunderscore{}FIFO or SCHED\textunderscore{}RR for 
this process \cite{sched-setscheduler}. 
In order to provide a more intuitive interaction a wrapper was written around the 
system call. This provides a more 'D like' interface, and enables a level of
abstraction to be taken from manually mapping D onto C for each application. 
\begin{lstlisting}[language=C++]
public import core.sys.posix.sched 
                : SCHED_FIFO, SCHED_OTHER, SCHED_RR; 

void setScheduler(int scheduler_type, int scheduler_priority)
{
    import core.sys.posix.sched 
                : sched_param, sched_setscheduler; 

    sched_param sp = { 
        sched_priority: scheduler_priority 
    }; 

    int ret = sched_setscheduler(0, scheduler_type, &sp); 
    if (ret == -1) {
        throw new Exception("scheduler did not properly set");
    }
}

void setFIFOScheduler(int schedPriority)
{
    setScheduler(SCHED_FIFO, schedPriority);
}

void setRRScheduler(int schedPriority)
{
    setScheduler(SCHED_RR, schedPriority); 
}
\end{lstlisting}
This can then be called in the following manner: 
\begin{lstlisting}
void main()
{
    setFIFOScheduler(50); 
}
\end{lstlisting}
The ability to set the scheduler to use a priority based method, combined with 
D language's previously present ability to set the priority of a thread therefore 
enables a priority based scheduling approach to be used.  

\section{Requirements 3 and 4: Monotonic Clocks and Absolute Sleep}
As mentioned in the previous section, it is a necessary feature of a real-time 
systems programming language to be able to sleep until an absolute time, rather 
than a relative time. In addition, this sleep must use a monotonic clock in order 
to remove any subjection from clock-drift or time-zone changes. D has support 
for a monotonic clock as part of the core libraries 
\cite{dlang-core-time}. This is accessible using 
\texttt{MonoTime}. Unfortunately there is no ability to sleep until an 
absolute time. Using D's ability to interact with C libraries, it is possible 
to leverage GlibC's ability to perform this operation: the C function 
\texttt{clock\textunderscore{}nanosleep} allows an absolute time to be specified
\cite{clock-nanosleep}.
A wrapper function has been provided as part of the real-time library this 
project provides: \texttt{delayUntil}.
This function accepts the D type \texttt{MonoTime} as an input, converts it to the C 
equivalent, and calls the C function \texttt{clock\textunderscore{}nanosleep}, 
allowing an absolute delay. The code is displayed below: 
\begin{lstlisting}
void delayUntil(MonoTime timeIn)
{
    import core.sys.linux.time; 
    import core.time : Duration, timespec; 
    Duration dur = timeIn - MonoTime(0) ;
    long secs, nansecs; 
    dur.split!("seconds", "nsecs")(secs, nansecs); 
    timespec sleep_time = timespec(secs, nansecs); 
    if (clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, 
                                    &sleep_time, null)) {
        throw new Exception("Failed to sleep as expected!"); 
    }
}
\end{lstlisting}
This allows simplistic use from a real-time application. An absolute sleep can 
be performed in the following manner: 
\begin{lstlisting}
void main()
{
    auto time = MonoTime.currTime(); 
    time += 3.seconds; 
    delayUntil(time);
}
\end{lstlisting}
As such, the D programming language can easily provide the ability to sleep 
until an absolute time. In order to easily the use of this functionality, a 
wrapper has been provided, giving an interface to D.

\section{Requirements 5 and 6: Bounded Priority Inversion}
In D, Mutexes follow a similar approach to Threads: the language's
implementation provides a wrapper around operating system calls, this 
enables operating system independent code to be written simply. However, D has no 
inherent ability to provide priority inversion handling protocols. 
\par\bigskip\noindent
Due to the underlying implementation of D's mutexes, there are two alternative 
approaches to defining the priority inheritance and priority ceiling protocols: 
either the current implementation may be extended to incorporate system calls 
setting the POSIX mutexes as using these protocols, or a new, language level 
mutex can be added that defines these protocols. As real-time systems have been 
shown to only be viable on operating systems that are POSIX compliant, and due to 
the quantity of work involved in reimplementing and defining these protocols, the 
decision was made to use POSIX mutexes. 
\par\bigskip\noindent
It is worth noting that the priority inheritance and priority ceiling protocols 
are available when using POSIX mutexes in C. 
\cite{mutex-setprotocol}. However, even though D's implementation of the \texttt{Mutex} 
class uses POSIX mutexes, it does not not set the protocol during their creation. 
As requirement 8 highlights the importance of an unmodified runtime, the 
constructor for this class cannot be extended, instead it must be fully 
reimplemented with an alterative imlpmentation of the constructer adding in 
the C function \texttt{pthread\textunderscore{}mutexattr\textunderscore{}setprotocol} \cite{mutex-setprotocol}. 
The full implementation of this mutex class is defined:
\lstinputlisting[language=Java]{rtmutex.d}
A mutex may then be created and initialised in the following manner: 
\begin{lstlisting}
auto a = new RTMutex(PRIORITY_INHERIT);
\end{lstlisting}
However, this is not a very D-like implementation: enums are not widely used 
in constructors. Instead, as with the scheduler calls, 
it is more intuitive to wrap this into two separate classes. Additionally, 
further support 
is needed to set and retrieve the priority ceiling associated with the 
mutex. This can achieved in a similar manner, additional 
functions can extend the class, providing a wrapper around the C functions 
\texttt{pthread\textunderscore{}mutex\textunderscore{}getprioceiling} and 
\texttt{pthread\textunderscore{}mutex\textunderscore{}setprioceiling}.
This can be conveniently wrapped in the following manner. 
\begin{lstlisting}
class CeilingMutex 
{
    private import core.sync.exception : SyncError;
    alias ceilingMutex this;
    RTMutex ceilingMutex;

    // Initializes a new CeilingMutex
    this()
    {
        ceilingMutex = new RTMutex(PROTOCOL_CEILING);
        this.ceiling = 1;
    }

    final @property int ceiling()
    {
        int ceiling; 
        if(pthread_mutex_getprioceiling(this.handleAddr, 
                                                &ceiling))
            throw new SyncError("Unable to fetch the priority 
                           ceiling for the associated Mutex"); 
        return ceiling; 
    }

    final @property void ceiling(int val)
    {
        if(pthread_mutex_setprioceiling(this.handleAddr, 
                                                val, null))
            throw new SyncError("Unable to set the priority 
                           ceiling for the associated Mutex"); 
    }
}
\end{lstlisting}
This allows the priority ceiling to be set or get as if it were a property of 
the \texttt{RTMutex} class. Similarly, the functions defined in \texttt{RTMutex} 
can be accessed as though they were part of the \texttt{CeilingMutex} class. 
A similar result is achieved for the \texttt{InheritanceMutex} class.
This allows a very idiomatic and readable interaction: 
\begin{lstlisting}
auto a = new CeilingMutex;
a.ceiling = 50; 
writeln("priority ceiling of a is: ", a.ceiling); 
synchronized(a) 
{
    // do something
}
\end{lstlisting}
Therefore, on a POSIX compliant operating system, the ability to interact with 
existing C libraries enables an implementation of a mutex, similar to the languages 
core model, to be extended, incorporating both the priority inheritance and 
priority ceiling protocols. Wrappers around this \texttt{RTMutex} class for 
either protocol, and around the C functions 
\texttt{pthread\textunderscore{}mutex\textunderscore{}setprioceiling} 
and \texttt{pthread\textunderscore{}mutex\textunderscore{}getprioceiling{}} 
provide an easy to use and intuitive implementation. 

\section{Requirement 7: Asynchronous Transfer of Control} % 600 words
The final primitive required for a programming language to support the development 
of a real-time system is the ability to perform an asynchronous transfer of 
control (ATC). This entails providing a section of code that can be interrupted 
and aborted at any moment in time asynchronously.
As detailed in the previous section, there are several different methods of 
achieving this aim. Here, each method is considered, and the logic behind the 
implementation explained. 

\subsubsection*{Setjmp and Longjmp} 
Through D's interaction with C, asynchronous transfer of control can be achieved 
through use of the commands, \texttt{setjmp} and \texttt{longjmp}. These allow 
the control of flow to be altered in a program by marking a location in code when 
\texttt{setjmp} is called, and jumping to this saved location when \texttt{longjmp} 
is called. It is possible to asynchronously invoke the \texttt{longjmp} function
through the use of POSIX signals, and a signal handler. This allows an asynchronous 
signal to effect the flow of control. However, due to the lack of concern for 
stack management, it is common for the stack to become corrupted using this approach
\cite{unwinding-stack}. As ATC will typically involve altering the current function, 
it is likely to affect the stack and would therefore not provide a memory safe 
implementation in D. As a result of this poor memory management, this method was 
not implemented in the end product, and is not a viable solution for asynchronous 
transfer of control in D. 

\subsubsection*{Thread Cancellation}
The second approach considered for the implementation of ATC in D is a thread 
cancellation approach. As previously shown, D's \texttt{Thread} class maps down onto 
operating specific threads. For POSIX compliant operating systems, it therefore 
uses pthreads. When using pthreads, it is possible to terminate a thread during 
it's execution using the \texttt{pthread\textunderscore{}cancel} function. 
In both methods, an \texttt{Interruptible} class abstracts the setup and running of an 
ATC section. 
Initialising the class will create a new \texttt{Thread}, 
inheriting the priority of the calling \texttt{Thread}. 
On calling a \texttt{start} function, execution of the calling 
\texttt{Thread} will then suspend, waiting for whatever the abortable section 
of code to be executed within the \texttt{Interruptible} class.
The aim of this class is to provide a friendly interaction 
that removes concern over the underlying implementation. 
For the asynchronous interrupt mechanism, using \texttt{pthread\textunderscore{}cancel} 
two alternative approaches were considered.
The first approach incorporates the Java style, having a 
\texttt{Thread.interrupt()} method. A similar method could be implemented in D. 
This provides an easy to use syntax that acts in the following manner, 
interrupting a \texttt{Thread} if it has not completed after 2 seconds.
\begin{lstlisting}
void interruptibleCode()
{
    while(true)
    {
        // loop forever.
    }
}

void main()
{
    void threadFn()
    {
        new Interruptible(&interruptibleCode).start(); 
    }

    auto a = new Thread(&threadFn); 
    a.start(); 
    Thread.sleep(2.seconds); 
    a.interrupt();
}
\end{lstlisting}
The second approach instead placed this \texttt{interrupt} method as part of the 
\texttt{Interruptible} class. Contrastingly, this would be invoked in the following
manner: 
\begin{lstlisting}
void interruptibleCode()
{
    while(true)
    {
        // loop forever.
    }
}

void main()
{
    __gshared Interruptible a; 
    void threadFn()
    {
        a = new Interruptible(&interruptibleCode)
        a.start(); 
    }

    new Thread(&threadFn).start(); 
    Thread.sleep(2.seconds); 
    a.interrupt();
}
\end{lstlisting}
While the difference between the two approaches may appear small, it is significant: 
in the first implementation, a thread containing multiple \texttt{Interruptible} 
sections of code may have a later section interrupted by a call to \texttt{interrupt}
not intended for it. This may lead to a cause of unexpected behaviour, and therefore 
a decision was made to implement the second approach. 
\par\bigskip\noindent
So far, it has been assumed that the interrupt function performs the exact 
functionality required. 
However, using \texttt{pthread\textunderscore{}cancel} alone does not guarantee 
an immediate cancellation: it is only guaranteed 
to cancel once both a signal is received and a cancellation point in the code 
is reached. 
Many standard C functions are defined as being thread cancellation points, however, 
there is no guarantee that these may be called within the target thread 
\cite{pthread-cancel-points}. As a result of this, it is possible to set the 
cancellation of a thread to be immediate through the function 
\texttt{pthread\textunderscore{}setcanceltype}, by setting the value to 
\texttt{PTHREAD\textunderscore{}CANCEL\textunderscore{}ASYNCHRONOUS}. This is 
crucial in either tight loops, or where cancellation must be immediate. 
\par\bigskip\noindent
However, this immediate cancellation comes at the cost of safety: interrupting a 
thread during the middle of a crucial function call, such as a memory allocation, 
may leave memory in an inconsistent state. In order to safely use this functionality, 
thread cancellation must therefore be deferred during certain sections of code, 
and enabled during others. This gives rise to the requirement of having 
deferred regions of code, in which operations can be executed with no risk of 
being cancelled. Two alternative approaches were considered for the implementation 
of this approach. The first approach considered was to have a method of the 
\texttt{Interruptible} class that allow the cancellation type to be toggled 
between \texttt{PTHREAD\textunderscore{}CANCEL\textunderscore{}ENABLE}
and \texttt{PTHREAD\textunderscore{}CANCEL\textunderscore{}DISABLE}
The second approach is to toggle boolean flags in the \texttt{Interruptible} class. 
By using these flags it is possible to determine whether a section of code is 
currently deferred from being interrupted or not. 
Furthermore, any pending interrupt that arrives when interrupts are deferred may 
be stored. When interrupts are re-enabled, this interrupt may then be triggered. 
Conceptually, the two approaches are similar. However, the first approach does 
not provide a viable method for nesting \texttt{Interruptible} classes. As it is 
possible for a second interruptible class to be nested within the first, setting 
\texttt{PTHREAD\textunderscore{}CANCEL\textunderscore{}DISABLE} may cause an 
inner \texttt{Interruptible} to be non-interruptible, even though its outer parent 
has been cancelled. In order to provide a fine-grained control over the two, 
even in the cases where nesting is possible, both these methods are implemented. 
Basic deferral can be achieved through the \texttt{deferred} properties. In order 
to execute code safely, even in nested cases, an \texttt{executeSafely} method that 
defers the cancellation has been implemented as follows. 
\begin{lstlisting}
class Interruptible
{
    ..

    void executeSafely(void delegate() fn)
    {
        if (pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, 
                                                    null))
        {
            throw new Error("Unable to set thread cancellation 
                                                    state");
        }
        fn();
        if (pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, 
                                                      null))
        {
            throw new Error("Unable to set thread cancellation 
                                                    state");
        }
    }
}
\end{lstlisting}
this may then be used in the following manner. 
\begin{lstlisting}
alias getInt = Interruptible.getThis;
void interruptibleFunction() 
{
    for(int i = 0; i < 10; i++)
    {
        void update() 
        {
            // perform some memory allocation
            void* x = GC.malloc(10_000); 
        }
        getInt.executeSafely(&update);
    }
}
\end{lstlisting}
This provides a safe mechanism for handling memory allocation, or critical sections 
of code. Furthermore, this enables code to be executed safely despite being 
nested in outer \texttt{Interruptible} classes. 
\par\bigskip\noindent
Additionally, it is often desirable to execute code once the cancellation has taken 
place. In C with POSIX threads, this can be achieved through the use of the 
\texttt{pthread\textunderscore{}cleanup\textunderscore{}push} function. 
This is achievable through use of D's interoperability with C. Again, functions are provided 
that wrap this functionality, providing a more usable interface. An example of using 
this cleanup code is as follows: 
\begin{lstlisting}
__gshared Interruptible a; 

extern (C) void thread_cleanup(void* arg) nothrow
{
    writeln("Cleanup Function");
}

void interruptibleFn()
{
    auto a = addCleanup(&thread_cleanup, cast(void*)void);
    while(true)
    {
        // loop forever
    }
}
\end{lstlisting}
This provides the desired functionality of ATC, as set out in requirement 7, 
through the use of thread cancellation in a two-thread model.

%TODO ------
\subsubsection*{Exceptions and Signals}
An alternative approach to the implementation of ATC is to use D's inbuilt Exception/Error 
handling mechanisms. Errors and Exceptions are typically used explicitly within code 
to affect the flow of control within a program.
For a POSIX system, it is possible to asynchronously invoke code remotely using 
signals and signal handlers. While typically used on a process wide level, it
is also possible to invoke these signal handlers for a specific thread through
the use of a C function, \texttt{pthread\textunderscore{}kill}. By using a
real-time signal, such as SIGRTMIN, there are guarantees that the signal
arrives in a timely manner, and that any signals are sent in the correct order. 
Thus, in D, it is possible to remotely invoke code in a \texttt{Thread} through 
the use of signals and signal handlers. This can be also be used to remotely
throw an exception. The following example shows a simple invocation of ATC
using achieved by throwing and catching an exception to break out of an
infinite loop. 
\begin{lstlisting}
import core.sys.posix.pthread, 
       core.sys.posix.signal, 
       std.stdio;

Exception ex = new Exception("Remotely Triggered Exception"); 

extern (C) void sig_handler(int signum) @nogc nothrow
{
    throw ex;
}

void setupSignalHandler()
{
    sigaction_t action; 
    action.sa_handler = &sig_handler; 
    sigemptyset(&action.sa_mask);
    sigaction(36, &action, null); 
}

void threadFunction()
{
    writeln("This is the thread"); 
    while(true)
    {
        Thread.sleep(1.seconds);
    }
}

void main()
{
    setupSignalHandler; 

    auto a = new Thread(&threadFunction); 
    a.start; 

    Thread.sleep(1.seconds); 
    pthread_kill(a.id, 36); 
}
\end{lstlisting}
% TODO - TALK ABOUT DELAYING THE EXCEPTION 
% TODO - TALK ABOUT NESTING OF SECTIONS 
% TODO - TALK ABOUT SAFETY OF THROWING EXCEPTION 
% TODO - TALK ABOUT CLEANUP ROUTINES 
% TODO - MENTION THAT IT IS SIMILAR IMPLEMENTATION TO THREAD CANCELLATION 
% TODO - HIGHLIGHT THE DIFFERENCES BETWEEN THE TWO METHODS - IE Exception
% REQUIRES SOME ADDITIONAL SETUP, BUT ONLY USES 1 THREAD. ALSO DEPENDS ON THE
% SETUP OF THE STACK, SO MAY DIFFER ON DIFFERENT ARCHITECTURES.

%throwing an Error when an asynchronous signal is received and 
%catching that error when leaving the interruptible section. This can be 
%achieved through having explicit methods such as \texttt{enableAsynchronousInterrupts()}
%and \texttt{disableAsynchronousInterrupts()}. However, this can lead to error 
%prone programs, where \texttt{enableAsynchronousInterrupts()} is called and not 
%followed later by a call to \texttt{disableAsynchronousInterrupts()}. 
%In addition, this does not permit the ability to nest interruptible sections. 

%TODO ------
\section{Requirement 9: Provision of Testing Facilities}
In order to verify the correct behaviour of the completed implementation, a set 
of tests have be provided. These tests allow a new systems viability 
to be tested, and improve the maintainability of the system. D provides a built-in 
functionality for unit-testing: using the \texttt{unittest} flag, test code can 
be placed alongside function declarations. In addition, assert statements allow 
expected behaviour to be verified. 
This is shown in the following sample:
\begin{lstlisting}
int triple(int i) {
    return i*3; 
}
unittest {
    assert(triple(0) == 0); 
    assert(triple(-4) == -8); 
    assert(triple(10) == 20); 
    assert(12.triple == 36);
}
\end{lstlisting}
For testing, a compiler flag using the two most popular compilers, LDC and DMD, 
inserts any \texttt{unittest} code into the main function. A main function may 
also be artificially created through a compiler flag. This allows the 
full testing of library code through a compiler invocation in the following manner: 
\begin{lstlisting}
ldc -main -unittest -run realtime.d
\end{lstlisting}
This inbuilt definition of \texttt{unittest} allows unit-testing to occur 
without the need for tools external to the core language, thus providing a convenient 
and practical testing method. 
