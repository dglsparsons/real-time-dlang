% The Design and Implementation Section - plenty to discuss in here - how 
% each different part of the system has been designed and implemented, as well
% as what the original design aims were. 

% Lots of things to check off in this section

%Formulate a moderate sized problem, to select and justify an appropriate approach, 
%and to follow the approach systematically. 
%Examined in the design/implementation chapters of the project. 

%Recognise alternatives, selecting and justifying the approach taken at each 
%point in the report, identifying parts of the project area that are feasible 
%within the time (etc) constraints of the project. Examined in the 
%design/implementation chapters of the project. 

%Appreciate the latent issues of the subject area (for example, in software 
%engineering they might meet and tackle such as emergent requirements, design 
%flaws, equipment/application problems). Examined in the project 
%design/implementation and evaluation chapters. 


% Word Count Estimate - 2500 Words



\section{Design Aims}
% Using D Way that D works - hooks into C standard libraries in order to 
% provide support for things. 

% Targeting POSIX operating Systems - real time features, not many other OS 
% can do this. 

% Ability to target different compilers, not require custom runtimes. 
% GIVES THE ESSENTIAL - Program written with no knowledge of the Real-time
% systems additions I am creating will not be effected. This means support can 
% be added in through importing a library. 

\section{Implementation}

In the previous section, the characteristics a real-time 
systems programming language would need to provide in order to enable the 
development of a real-time system were discussed. The aim of this project has been primarily to 
provide these primitives to the D programming language, and hence any discussion, 
design decisions and the implementation of these features is discussed in this 
section. 

\subsection{Threads and Interprocess Communication}
D, being a C/C++ style language, provides support for the creation and use of 
threads. Threads in D follow a Java style approach: Thread is a class, 
allowing subclasses to be derived and methods to be overridden. The default 
class method will allow a function to be passed by reference and executed. 
This is seen in the example below, taken from the D website
\cite{core-thread}: 
\begin{lstlisting}
class DerivedThread : Thread
{
    this()
    {
        super(&run);
    }
    private:
    void run()
    {
        // Derived thread running.
    }
}

void threadFunc()
{
    // Composed thread running.
}

// create and start instances of each type
auto derived = new DerivedThread().start();
auto composed = new Thread(&threadFunc).start();
\end{lstlisting}
We can therefore see that the primitive of Threads and interprocess communication 
is already provided by D. However, the implementation is of interest: D 
provides an agnostic approach to operating systems, supporting Windows, FreeBSD, 
OSX and Linux. 
In order to provide support for this wide range of operating systems, the Thread 
class contains operating system specific code, mapping down a standard interface 
onto various underlying implementations 
\cite{github-core-thread}. 
We are interested only in operating systems 
that support real-time applications, and as such all additions made to D with 
regards to real-time applications are specifically targeting POSIX compliant 
operating systems, in particular those with real-time extensions. 
\par\bigskip\noindent
It is worth noting that the underlying operating system may not be fully
real-time compliant, even if it is POSIX compliant. Real-time patches to the 
Linux kernel exist 
\cite{rt-wiki}, enabling a greater 
guarantee over the responsiveness. Special care may also be required when 
developing such a system 
\cite {rt-wiki-how-to}. 

\subsection{Monotonic Clocks and Absolute Sleep}
%TODO - Mention what the default sleep method maps onto. 
As mentioned in the previous section, it is a necessary feature of a real-time 
systems programming language to be able to sleep until an absolute time, rather 
than a relative time. In addition, this sleep must use a monotonic clock in order 
to remove any subjection from clock-drift or time-zone changes. D has support 
for a monotonic clock as part of the core libraries 
\cite{dlang-core-time}. We can access this using 
\texttt{MonoTime}, but unfortunately there is no ability to sleep until an 
absolute time. Using D's ability to interact with C libraries, it is possible 
to leverage Glibc's ability to perform this operation: the C function 
clock\textunderscore{}nanosleep allows an absolute time to be specified.
\cite{clock-nanosleep}
A wrapper function has been provided as part of a real-time library, delayUntil. 
This function accepts the D type MonoTime as an input, converts it to the C 
equivalent, and calls the C function clock\textunderscore{}nanosleep, allowing an absolute delay.
The code is displayed below: 
\begin{lstlisting}
void delayUntil(MonoTime timeIn)
{
    import core.sys.linux.time; 
    import core.time : Duration, timespec; 
    Duration dur = timeIn - MonoTime(0) ;
    long secs, nansecs; 
    dur.split!("seconds", "nsecs")(secs, nansecs); 
    timespec sleep_time = timespec(secs, nansecs); 
    if (clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, 
                                    &sleep_time, null)) {
        throw new Exception("Failed to sleep as expected!"); 
    }
}
\end{lstlisting}
This allows a simplistic use from a real-time application. An absolute sleep can 
then be performed in the following manner: 
\begin{lstlisting}
void main()
{
    auto time = MonoTime.currTime(); 
    time += 3.seconds; 
    delay_until(time);
}
\end{lstlisting}
As such, the D programming language can easily provide the ability to sleep 
until an absolute time. In order to easily use this functionality, a 
wrapper has been provided.

\subsection{Priority Scheduling}
The ability to correctly schedule tasks or threads based on their priority is of 
critical importance to a real-time system. As previously discussed within this 
section, D provides the isolation mechanic of a Thread, easily allowing the 
separation of concern. Additionally, the Thread class contains the parameter, 
priority, that can be used to set or get a thread's priority
\cite{core-thread}. 
However, in order for priority based scheduling to be used, this alone is not 
enough: the scheduler must be changed to function in a priority based manner. 
It was previously identified that D's threads provide a mapping onto an operating  
system thread, and hence it is the operating system scheduler that has to be set.  
No support exists within the D standard libraries to interact with the scheduler 
however, so this support has to be supplied. 
This was achieved once again through interaction with Glibc: the function 
sched\textunderscore{}setscheduler allows the operating system scheduler to 
be set to either SCHED\textunderscore{}FIFO or SCHED\textunderscore{}RR for 
this process
\cite{sched-setscheduler}. 
As with the delayUntil function, a wrapper has been added around the C function,
providing a simpler interface: 
\begin{lstlisting}[language=C++]
public import core.sys.posix.sched 
                : SCHED_FIFO, SCHED_OTHER, SCHED_RR; 

void setScheduler(int scheduler_type, int scheduler_priority)
{
    import core.sys.posix.sched 
                : sched_param, sched_setscheduler; 

    sched_param sp = { 
        sched_priority: scheduler_priority 
    }; 

    int ret = sched_setscheduler(0, scheduler_type, &sp); 
    if (ret == -1) {
        throw new Exception("scheduler did not properly set");
    }
}
\end{lstlisting}
This can then be called in the following manner: 
\begin{lstlisting}
void main()
{
    setScheduler(SCHED_FIFO, 0); 
}
\end{lstlisting}
The ability to set the scheduler to use a priority based method, combined with 
D language's previously present ability to set the priority of a thread therefore 
enables a priority based scheduling approach to be used.  

\subsection{Bounded Priority Inversion}
In D, Mutexes follow a similar approach to Threads: the language's
implementation provides a wrapper around operating system calls, this 
enables operating system independent code to be written simply. However, D has no 
inherent ability to provide priority inversion handling protocols. 
However, these protocols are already provided for POSIX compliant Mutexes 
\cite{mutex-setprotocol}. On a POSIX 
compliant operating system D will use this mutex type but not set the protocol. 
By interacting with Glibc, the default mutex class can be inherited
and provided with a constructor that sets this property.
A mutex created like this may then be initialised in the following manner: 
%TODO - GIVE FULL DEFINITION OF RTMUTEX
\begin{lstlisting}
auto a = new RTMutex(PRIORITY_INHERIT);
\end{lstlisting}
Additionally, support is needed to set and receive the priority ceiling 
associated with the mutex. This is achieved in a similar manner: additional 
functions can be added providing a wrapper around the C functions 
\texttt{pthread\textunderscore{}mutex\textunderscore{}getprioceiling} and 
\texttt{pthread\textunderscore{}mutex\textunderscore{}\\setprioceiling}
in the following manner:
\begin{lstlisting}
final @property int ceiling()
{
    int ceiling; 
    if(pthread_mutex_getprioceiling(&m_hndl, &ceiling))
    throw new SyncError("Unable to fetch the priority 
                    ceiling for the associated Mutex"); 
    return ceiling; 
}
\end{lstlisting}
This allows the priority ceiling to be set or get as if it were a property of 
the class. Allowing a very idiomatic and readable interaction: 
\begin{lstlisting}
auto a = new RTMutex(PRIORITY_CEILING); 
a.ceiling = 50; 
writeln("priority ceiling of a is: ", a.ceiling); 
\end{lstlisting}
Therefore, on a POSIX compliant operating system, the ability to interact with 
existing C libraries enables D to provide a subclass of the language's default 
Mutex class. This subclass is capable of providing either the priority ceiling 
protocol or the priority inheritance protocol. Wrappers around the C functions 
enable this to be used in an intuitive manner. 

\subsection{Asynchronous Transfer of Control}
The final primitive required for a programming language to support the development 
of a real-time system is the ability to perform an asynchronous transfer of 
control. As detailed in the previous section, this entails providing a 
section of code that can be interrupted at any moment in time asynchronously. 
When using C with POSIX threads, this can be achieved through clever use of 
setjmp and longjmp, combined with SIG handlers. This allows an asynchronous 
signal to effect the flow of control. A similar approach can be taken in D, 
however the complexity of such a system and unsafe management of the stack when 
calling longjmp 
\cite{unwinding-stack} mean that it is not especially feasible. 
An alternative approach is to set a thread's cancellation type using to 
\texttt{PTHREAD\textunderscore{}CANCEL\textunderscore{}ASYNCHRONOUS} using 
\texttt{pthread\textunderscore{}setcanceltype}. This then allows a thread to 
be asynchronously cancelled using \texttt{pthread\textunderscore{}cancel}. Cleanup 
is also possible using this mechanism through the use of 
\texttt{pthread\textunderscore{}cleanup\textunderscore{}pop}. However, 
this method is complicated to implement, requiring a thread to resume from an 
arbitrary point after its cancellation. In addition, this becomes further 
complicated by the desire to nest interruptible sections of code. 
Ada takes a similar approach to this, using a multi-threaded model. 
\par\bigskip\noindent
An alternative approach is use the inbuilt Exception/Error handling mechanisms 
that D provides, throwing an Error when an asynchronous signal is received and 
catching that error when leaving the interruptible section. This can be 
achieved through having explicit methods such as \texttt{enableAsynchronousInterrupts()}
and \texttt{disableAsynchronousInterrupts()}. However, this can lead to error 
prone programs, where \texttt{enableAsynchronousInterrupts()} is called and not 
followed later by a call to \texttt{disableAsynchronousInterrupts()}. 
In addition, this does not permit the ability to nest interruptible sections. 
