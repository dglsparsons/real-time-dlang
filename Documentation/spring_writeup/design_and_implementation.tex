% The Design and Implementation Section - plenty to discuss in here - how 
% each different part of the system has been designed and implemented, as well
% as what the original design aims were. 

%Formulate a moderate sized problem, to select and justify an appropriate approach, 
%and to follow the approach systematically. 
%Examined in the design/implementation chapters of the project. 

%Recognise alternatives, selecting and justifying the approach taken at each 
%point in the report, identifying parts of the project area that are feasible 
%within the time (etc) constraints of the project. Examined in the 
%design/implementation chapters of the project. 

%Appreciate the latent issues of the subject area (for example, in software 
%engineering they might meet and tackle such as emergent requirements, design 
%flaws, equipment/application problems). Examined in the project 
%design/implementation and evaluation chapters. 


% Word Count Estimate - 2500 Words

% \section{Design Aims} -- MAYBE DON'T NEED THIS BIT AS THE REQUIREMENTS ARE TO
% BE FORMULATED FROM THE LIT REVIEW SECTION 

% Using D Way that D works - hooks into C standard libraries in order to 
% provide support for things. 

% Targeting POSIX operating Systems - real time features, not many other OS 
% can do this. 

% Ability to target different compilers, not require custom runtimes. 
% GIVES THE ESSENTIAL - Program written with no knowledge of the Real-time
% systems additions I am creating will not be effected. This means support can 
% be added in through importing a library. 
In previous chapters,
existing real-time system programming languages have been examined in order to
define a set of required functionality. From this, a set of project requirements 
has been determined. 
This chapter aims to describe the implementation of these requirements into the D
programming language, highlighting the completed implementations and any design 
decisions made along the way. 
For each of the functional requirements of the project, the potential
implementations are discussed. In this discussion, any design 
decisions that have been made will be explained. Furthermore, this chapter will 
detail the completed implementation of each component. 

\section{Method of Provision}
% Library vs modified runtime ? 
For the end goal of this project to be usable, various methods for its delivery 
were considered. There are two significant alternatives. 
If the compiler or the 
core runtime features of the language do not need to be altered to provide the 
desired functionality, 
the project may then be packaged as an external library. 
This is the most desirable end goal, hence the addition of requirement 8: no
modifications to the language's compiler or core libraries. 
Failing this, a modified runtime and/or compiler would need be provided.
Although this would 
enable the development of real-time systems, the modified system would 
require maintenance to keep it up to date with the core set of D functionality. 

\section{Requirement 1: Threads and Interprocess Communication}
D, being a C/C++ style language, provides support for the creation and use of 
threads. Threads in D follow a Java style approach: \texttt{Thread} is a class, 
allowing subclasses to be derived and methods to be overridden. The default 
class method will allow a function to be passed by reference and executed. 
These features can be seen in the example below, taken from the D website
\cite{core-thread}: 
%TC:ignore
\begin{lstlisting}[basicstyle=\small]
import core.Thread; 

class DerivedThread : Thread
{
    this()
    {
        super(&run);
    }
    private:
    void run()
    {
        // Derived thread running.
    }
}

void threadFunc()
{
    // Composed thread running.
}

// create and start instances of each type
void main()
{
    auto derived = new DerivedThread();
    auto composed = new Thread(&threadFunc);
    derived.start; 
    composed.start;
}
\end{lstlisting}
%TC:endignore
It is therefore evident that D already provides 
concurrent control of system components, along with mechanisms for 
interprocess communication. However, the implementation is of interest: D 
provides an agnostic approach to the underlying operating system, supporting 
Windows, FreeBSD, OSX, Linux and Solaris. 
In order to provide support for this wide range of operating systems, the 
\texttt{Thread}
class contains operating system specific code, mapping down a standard interface 
onto various underlying implementations 
\cite{github-core-thread}. 
This project is interested only in operating systems capable of meeting tight timing 
requirements in any calls to the kernel and context switching.
As such, all additions made to D with regards to real-time applications are 
specifically targeted at POSIX compliant 
operating systems, in particular those with real-time extensions. 
\par\bigskip\noindent
It is worth noting that the underlying operating may require patching in order 
to be fully viable for a real-time system: the system may not be fully
real-time compliant even if it is POSIX compliant. Because of this, real-time patches 
to the Linux kernel exist \cite{rt-wiki}. These enable a greater 
guarantee over the timeliness of the kernel. 
Furthermore, special care must also be taken when developing such a system,
selecting appropriate hardware and programming the system in a manner appreciative 
of the underlying hardware \cite{rt-wiki-how-to}.

\section{Requirement 2: Priority Based Scheduling}
The ability to correctly schedule tasks or threads based on their priority is of 
critical importance to a real-time system. As previously discussed, D provides 
concurrency through operating system Threads, encapsulated in the
\texttt{Thread} class. Additionally, the \texttt{Thread} class contains the 
parameter, \texttt{priority}. This parameter can be used to set or get a
\texttt{Thread's} priority \cite{core-thread}. 
However, in order for priority based scheduling to be used, this alone is not 
enough: the scheduler must be changed to function in a priority based manner. 
It has been previously identified that D's threads provide a mapping onto an operating  
system thread, and hence it is the operating system scheduler that has to be set.  
However, no support exists within D's standard libraries to interact with the
scheduler. 
Therefore, this support has to be supplied. 
This can be achieved through interaction with C standard libraries, such as GlibC. 
The function \texttt{sched\textunderscore{}setscheduler} allows the operating system 
scheduler to be set to either SCHED\textunderscore{}FIFO or SCHED\textunderscore{}RR for 
this process \cite{sched-setscheduler}. 
In order to provide a more intuitive interaction, a wrapper was written around the 
system call. This provides a more 'D like' interface and enables a level of
abstraction to be taken from manually mapping D onto C for each application. 
%TC:ignore
\begin{lstlisting}[basicstyle=\small,language=C++]
public import core.sys.posix.sched 
                : SCHED_FIFO, SCHED_OTHER, SCHED_RR; 

void setScheduler(int scheduler_type, int scheduler_priority)
{
    import core.sys.posix.sched 
                : sched_param, sched_setscheduler; 

    sched_param sp = { 
        sched_priority: scheduler_priority 
    }; 

    int ret = sched_setscheduler(0, scheduler_type, &sp); 
    if (ret == -1) {
        throw new Exception("scheduler did not properly set");
    }
}

void setFIFOScheduler(int schedPriority)
{
    setScheduler(SCHED_FIFO, schedPriority);
}

void setRRScheduler(int schedPriority)
{
    setScheduler(SCHED_RR, schedPriority); 
}
\end{lstlisting}
%TC:endignore
This can then be called in the following manner: 
%TC:ignore
\begin{lstlisting}[basicstyle=\small]
void main()
{
    setFIFOScheduler(50); 
}
\end{lstlisting}
%TC:endignore
The ability to set the scheduler to use a priority based method, combined with 
the D language's ability to set the priority of a thread, 
enables a priority based scheduling approach to be used. It is worth noting
that on many operating systems, setting the scheduler requires super user
privileges. 

\section{Requirements 3 and 4: Monotonic Clocks and Absolute Sleep}
As mentioned in the previous section, it is a necessary feature of a real-time 
systems programming language to be able to sleep until an absolute time, rather 
than a relative time. In addition, this sleep must use a monotonic clock in order 
to remove any subjection from clock-drift or time-zone changes. D has support 
for a monotonic clock as part of the core libraries 
\cite{dlang-core-time}. This is accessible using 
\texttt{MonoTime}. Unfortunately there is no ability to sleep until an 
absolute time. Using D's ability to interact with C libraries, it is possible 
to leverage GlibC's ability to perform this operation: the C function 
\texttt{clock\textunderscore{}nanosleep} allows an absolute time to be specified
\cite{clock-nanosleep}.
A wrapper function has been provided as part of the real-time library this 
project provides: \texttt{delayUntil}.
This function accepts the D type \texttt{MonoTime} as an input, converts it to the C 
equivalent, and calls the C function \texttt{clock\textunderscore{}nanosleep}, 
allowing an absolute delay. The code is displayed below: 
%TC:ignore
\begin{lstlisting}[basicstyle=\small]
void delayUntil(MonoTime timeIn)
{
    import core.sys.linux.time; 
    import core.time : Duration, timespec; 
    Duration dur = timeIn - MonoTime(0) ;
    long secs, nansecs; 
    dur.split!("seconds", "nsecs")(secs, nansecs); 
    timespec sleep_time = timespec(secs, nansecs); 
    if (clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, 
                                    &sleep_time, null)) {
        throw new Exception("Failed to sleep as expected!"); 
    }
}
\end{lstlisting}
%TC:endignore
This allows simplistic use from a real-time application. An absolute sleep can 
be performed in the following manner: 
%TC:ignore
\begin{lstlisting}[basicstyle=\small]
void main()
{
    auto time = MonoTime.currTime(); 
    time += 3.seconds; 
    delayUntil(time);
}
\end{lstlisting}
%TC:endignore
As such, the D programming language can easily provide the ability to sleep 
until an absolute time. In order to easily use this functionality, a 
wrapper has been provided, giving an interface to D.

\section{Requirements 5 and 6: Bounded Priority Inversion}
In D, mutexes follow a similar approach to threads: the language's
implementation provides a wrapper around operating system calls. This 
enables operating system independent code to be written simply. However, D has no 
inherent ability to provide priority inversion handling protocols. 
\par\bigskip\noindent
%Due to the underlying implementation of D's mutexes, there are two alternative 
%approaches to defining the priority inheritance and priority ceiling protocols.
%In one approach, the current implementation may be extended to incorporate system calls 
%setting the POSIX mutexes as using these protocols. In the other approach, a language level 
%mutex can be added that defines these protocols. 
Real-time systems have been shown to only be viable on operating systems that 
are POSIX compliant, and due to the quantity of work involved in reimplementing 
and defining these protocols, the decision was made to use the languages
inbuilt POSIX mutexes. 
\par\bigskip\noindent
It is worth noting that the priority inheritance and priority ceiling protocols 
are available when using POSIX mutexes in C. 
\cite{mutex-setprotocol}. However, even though D's implementation of the \texttt{Mutex} 
class uses POSIX mutexes, it does not not set the protocol during their creation. 
As requirement 8 highlights the importance of an unmodified runtime, the 
constructor for this class cannot be extended. Instead it must be fully 
reimplemented with an alternative implementation of the constructor adding in 
the C function \texttt{pthread\textunderscore{}mutexattr\textunderscore{}setprotocol} \cite{mutex-setprotocol}. 
The full implementation of this mutex class is defined:
%TC:ignore
\lstinputlisting[language=Java]{rtmutex.d}
%TC:endignore
A mutex may then be created and initialised in the following manner: 
%TC:ignore
\begin{lstlisting}[basicstyle=\small]
auto a = new RTMutex(PRIORITY_INHERIT);
\end{lstlisting}
%TC:endignore
However, this is not a very D-like implementation: \texttt{enums} are not widely used 
in constructors. Instead, as with the scheduler calls, 
it is more intuitive to wrap this into two separate classes. Additionally, 
further support 
is needed to set and retrieve the priority ceiling associated with the 
mutex. This can achieved in a similar manner: additional 
functions can extend the class, providing a wrapper around the C functions 
\texttt{pthread\textunderscore{}mutex\textunderscore{}getprioceiling} and 
\texttt{pthread\textunderscore{}mutex\textunderscore{}setprioceiling}.
This can be conveniently wrapped in the following manner. 
%TC:ignore
\begin{lstlisting}[basicstyle=\small]
class CeilingMutex 
{
    private import core.sync.\texttt{Exception} : SyncError;
    alias ceilingMutex this;
    RTMutex ceilingMutex;

    // Initializes a new CeilingMutex
    this()
    {
        ceilingMutex = new RTMutex(PROTOCOL_CEILING);
        this.ceiling = 1;
    }

    final @property int ceiling()
    {
        int ceiling; 
        if(pthread_mutex_getprioceiling(this.handleAddr, 
                                                &ceiling))
            throw new SyncError("Unable to fetch the priority 
                           ceiling for the associated Mutex"); 
        return ceiling; 
    }

    final @property void ceiling(int val)
    {
        if(pthread_mutex_setprioceiling(this.handleAddr, 
                                                val, null))
            throw new SyncError("Unable to set the priority 
                           ceiling for the associated Mutex"); 
    }
}
\end{lstlisting}
%TC:endignore
This allows the priority ceiling to be set or retrieved as if it were a property of 
the \texttt{RTMutex} class. Similarly, the functions defined in \texttt{RTMutex} 
can be accessed as though they were part of the \texttt{CeilingMutex} class. 
A similar result is achieved for the \texttt{InheritanceMutex} class.
This allows an idiomatic and readable interaction: 
%TC:ignore
\begin{lstlisting}[basicstyle=\small]
auto a = new CeilingMutex;
a.ceiling = 50; 
writeln("priority ceiling of a is: ", a.ceiling); 
synchronized(a) 
{
    // do something
}
\end{lstlisting}
%TC:endignore
Therefore, on a POSIX compliant operating system, the ability to interact with 
existing C libraries enables an implementation of a mutex, similar to the languages 
core model, to be extended, incorporating both the priority inheritance and 
priority ceiling protocols. Wrappers around this \texttt{RTMutex} class for 
either protocol and around the C functions 
\texttt{pthread\textunderscore{}mutex\textunderscore{}setprioceiling} 
and \texttt{pthread\textunderscore{}mutex\textunderscore{}getprioceiling{}} 
provide an easy to use and intuitive implementation. 

\section{Requirement 7: Asynchronous Transfer of Control} % 600 words
The final primitive required for a programming language to support the development 
of a real-time system is the ability to perform an asynchronous transfer of 
control (ATC). This entails providing a section of code that can be interrupted 
and aborted at any moment in time asynchronously.
As detailed in the previous section, there are several different methods of 
achieving this aim. Here, each method is considered and the logic behind the 
implementation explained. 

\subsubsection*{Setjmp and Longjmp} 
Through D's interaction with C, asynchronous transfer of control can be achieved 
through use of the commands, \texttt{setjmp} and \texttt{longjmp}. These allow 
the control of flow to be altered in a program by marking a location in code when 
\texttt{setjmp} is called, and jumping to this saved location when \texttt{longjmp} 
is called. It is possible to asynchronously invoke the \texttt{longjmp} function
through the use of POSIX signals and a signal handler. This allows an asynchronous 
signal to effect the flow of control. However, due to the lack of concern for 
stack management, it is common for the stack to become corrupted using this approach
\cite{unwinding-stack}. As ATC will typically involve altering the current function, 
it is likely to affect the stack and would therefore not provide a memory safe 
implementation in D. As a result of this poor memory management, this method was 
not implemented in the end product, and is not a viable solution for asynchronous 
transfer of control in D. 

\subsubsection*{Thread Cancellation}
The second approach considered for the implementation of ATC in D is a thread 
cancellation approach. As previously shown, D's \texttt{Thread} class maps down onto 
operating specific threads. For POSIX compliant operating systems, it therefore 
uses pthreads. When using pthreads, it is possible to terminate a thread during 
its execution using the \texttt{pthread\textunderscore{}cancel} function. 
In both methods, an \texttt{Interruptible} class abstracts the setup and running of an 
ATC section. 
Initialising the class will create a new \texttt{Thread}, 
inheriting the priority of the calling \texttt{Thread}. 
On calling a \texttt{start} function, execution of the calling 
\texttt{Thread} will then suspend, waiting for the abortable section 
of code to be executed within the \texttt{Interruptible} class.
The aim of this class is to provide a friendly interaction 
that removes concern over the underlying implementation. 
For the asynchronous interrupt mechanism, using
\texttt{pthread\textunderscore{}cancel},
two alternative approaches were considered.
The first approach incorporates the Java style, having a 
\texttt{Thread.interrupt()} method. A similar method could be implemented in D. 
This provides an easy to use syntax that acts in the following manner, 
interrupting a \texttt{Thread} if it has not completed after 2 seconds.
%TC:ignore
\begin{lstlisting}[basicstyle=\small]
void interruptibleCode()
{
    while(true)
    {
        // loop forever.
    }
}

void main()
{
    void threadFn()
    {
        new Interruptible(&interruptibleCode).start(); 
    }

    auto a = new Thread(&threadFn); 
    a.start(); 
    Thread.sleep(2.seconds); 
    a.interrupt();
}
\end{lstlisting}
%TC:endignore
The second approach instead placed this \texttt{interrupt} method as part of the 
\texttt{Interruptible} class. Contrastingly, this would be invoked in the following
manner: 
%TC:ignore
\begin{lstlisting}[basicstyle=\small]
void interruptibleCode()
{
    while(true)
    {
        // loop forever.
    }
}

void main()
{
    __gshared Interruptible a; 
    void threadFn()
    {
        a = new Interruptible(&interruptibleCode)
        a.start(); 
    }

    new Thread(&threadFn).start(); 
    Thread.sleep(2.seconds); 
    a.interrupt();
}
\end{lstlisting}
%TC:endignore
While the difference between the two approaches may appear small, it is significant: 
in the first implementation, a thread containing multiple \texttt{Interruptible} 
sections of code may have a later section interrupted by a call to \texttt{interrupt}
not intended for it. This may lead to a cause of unexpected behaviour and therefore 
a decision was made to implement the second approach. 
\par\bigskip\noindent
So far, it has been assumed that the interrupt function performs the exact 
functionality required. 
However, using \texttt{pthread\textunderscore{}cancel} alone does not guarantee 
an immediate cancellation: it is only guaranteed 
to cancel once both a signal is received and a cancellation point in the code 
is reached. 
Many standard C functions are defined as being thread cancellation points, but 
there is no guarantee that these may be called within the target thread 
\cite{pthread-cancel-points}. As a result of this, it is possible to set the 
cancellation of a thread to be immediate through the function 
\texttt{pthread\textunderscore{}setcanceltype}, by setting the value to 
\texttt{PTHREAD\textunderscore{}CANCEL\textunderscore{}ASYNCHRONOUS}. This is 
crucial in either tight loops or where cancellation must be immediate. 
\par\bigskip\noindent
However, this immediate cancellation comes at the cost of safety: interrupting a 
thread during the middle of a crucial function call, such as a memory allocation, 
may leave memory in an inconsistent state. In order to safely use this functionality, 
thread cancellation must therefore be deferred during certain sections of code 
and enabled during others. This gives rise to the requirement of having 
deferred regions of code, in which operations can be executed with no risk of 
being cancelled. Two alternative approaches were considered for the implementation 
of this feature. The first considered was to have a method of the 
\texttt{Interruptible} class that allow the cancellation type to be toggled 
between \texttt{PTHREAD\textunderscore{}CANCEL\textunderscore{}ENABLE}
and \texttt{PTHREAD\textunderscore{}CANCEL\textunderscore{}DISABLE}
The second approach is to toggle boolean flags in the \texttt{Interruptible} class. 
By using these flags it is possible to determine whether a section of code is 
currently deferred from being interrupted or not. 
Furthermore, any pending interrupt that arrives when interrupts are deferred may 
be stored. When interrupts are re-enabled, this interrupt may then be triggered. 
Conceptually, the two approaches are similar. However, the first approach does 
not provide a viable method for nesting \texttt{Interruptible} classes. As it is 
possible for a second interruptible class to be nested within the first, setting 
\texttt{PTHREAD\textunderscore{}CANCEL\textunderscore{}DISABLE} may cause an 
inner \texttt{Interruptible} to be non-interruptible, even though its outer parent 
has been cancelled. In order to provide a fine-grained control over the two, 
even in the cases where nesting is possible, both these methods are implemented. 
Basic deferral can be achieved through the \texttt{deferred} properties. In order 
to execute code safely, even in nested cases, an \texttt{executeSafely} method that 
defers the cancellation has been implemented as follows. 
%TC:ignore
\begin{lstlisting}[basicstyle=\small]
class Interruptible
{
    ..
    void executeSafely(void delegate() fn)
    {
        if (pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, 
                                                    null))
        {
            throw new Error("Unable to set thread cancellation 
                                                    state");
        }
        fn();
        if (pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, 
                                                      null))
        {
            throw new Error("Unable to set thread cancellation 
                                                    state");
        }
    }
}
\end{lstlisting}
%TC:endignore
this may then be used in the following manner. 
%TC:ignore
\begin{lstlisting}[basicstyle=\small]
alias getInt = Interruptible.getThis;
void interruptibleFunction() 
{
    for(int i = 0; i < 10; i++)
    {
        void update() 
        {
            // perform some memory allocation
            void* x = GC.malloc(10_000); 
        }
        getInt.executeSafely(&update);
    }
}
\end{lstlisting}
%TC:endignore
This provides a safe mechanism for handling memory allocation or critical sections 
of code. Furthermore, this enables code to be executed safely despite being 
nested in outer \texttt{Interruptible} classes. 
\par\bigskip\noindent
Additionally, it is often desirable to execute code once the cancellation has taken 
place. In C with POSIX threads, this can be achieved through the use of the 
\texttt{pthread\textunderscore{}cleanup\textunderscore{}push} function. 
This is achievable through use of D's interoperability with C. Again, functions are provided 
that wrap this functionality, providing a more usable interface. An example of using 
this cleanup code is as follows: 
%TC:ignore
\begin{lstlisting}[basicstyle=\small]
__gshared Interruptible a; 

extern (C) void thread_cleanup(void* arg) nothrow
{
    writeln("Cleanup Function");
}

void interruptibleFn()
{
    auto a = addCleanup(&thread_cleanup, cast(void*)void);
    while(true)
    {
        // loop forever
    }
}
\end{lstlisting}
%TC:endignore
This provides the desired functionality of ATC, as set out in requirement 7, 
through the use of thread cancellation in a two-thread model.

\subsubsection*{Exceptions and Signals}
An alternative approach to the implementation of ATC is to use D's inbuilt \texttt{Exception}/error 
handling mechanisms. Errors and \texttt{Exception}s are typically used explicitly within code 
to affect the flow of control within a program.
For a POSIX system, it is possible to asynchronously invoke code remotely using 
signals and signal handlers. While typically used on a process wide level, it
is also possible to invoke these signal handlers for a specific thread through
the use of a C function, \texttt{pthread\textunderscore{}kill}. By using a
real-time signal, such as SIGRTMIN, there are guarantees that the signal
arrives in a timely manner and that any signals are sent in the correct order. 
Thus, in D, it is possible to remotely invoke code in a \texttt{Thread} through 
the use of signals and signal handlers. This can be also be used to remotely
throw an \texttt{Exception}. The following example shows a simple invocation of ATC
using achieved by throwing and catching an \texttt{Exception}, breaking out of an
infinite loop: 
%TC:ignore
\begin{lstlisting}[basicstyle=\small]
import core.sys.posix.pthread, 
       core.sys.posix.signal, 
       std.stdio;

Exception ex = new Exception("Remotely Triggered Exception"); 

extern (C) void sig_handler(int signum) @nogc nothrow
{
    throw ex;
}

void setupSignalHandler()
{
    sigaction_t action; 
    action.sa_handler = &sig_handler; 
    sigemptyset(&action.sa_mask);
    sigaction(36, &action, null); 
}

void threadFunction()
{
    writeln("This is the thread"); 
    while(true)
    {
        Thread.sleep(1.seconds);
    }
}

void main()
{
    setupSignalHandler; 

    auto a = new Thread(&threadFunction); 
    a.start; 

    Thread.sleep(1.seconds); 
    pthread_kill(a.id, 36); 
}
\end{lstlisting}
%TC:endignore
The above example displays the simple principal behind this method of ATC.
However, there are many aspects of its behaviour that make the above
implementation impractical. 
First, ATC sections may be nested inside each other. Using the above 
method, it would not be possible to exit two ATC sections through a single interrupt
to the outermost section. This occurs because the \texttt{Exception} would be caught and
handled in the inner ATC section. 
Secondly, internal components may trigger \texttt{Exception}s or may have \texttt{Exception} handlers 
of their own. Using this approach, an \texttt{Exception} that is intended to perform ATC 
may instead be caught and would thus have no effect. 
In order to prevent this from happening, the final implementation for this
project does not use \texttt{Exceptions}, but instead uses D's notion of an
\texttt{Error}. Conceptually, \texttt{Errors} and \texttt{Exceptions} are
similar, both being throw and catch-able objects. 
However, they are used differently within D: \texttt{Exceptions} are used to
manage the control of flow under \texttt{Exception}al circumstances, whereas
\texttt{Errors} are typically used for terminating the program and tracing faults. 
However, the two also differ fundamentally. 
\texttt{Errors} are allowed to propagate through generic \texttt{Exception} catches, and thus propagate 
through all \texttt{Exception} handlers. In this regard, they exhibit the desired
behaviour, enabling abortable code to use \texttt{Exceptions} freely. The only
limitation here is that the end user does not program the
abortable code to catch all \texttt{Errors}. As errors generally occur when the
program is unable to run or corrupts memory, it is not advisable to do this. 
For Signal and \texttt{Exception} based ATC, rather than using a generic
\texttt{Error}, an \texttt{ATCInterrupt} class is defined. 
This class extends the \texttt{Error} class.
\par\bigskip\noindent
In order to allow nesting of Interruptible sections of code, the \texttt{Error} thrown
must also be rethrown if it is not caught by its corresponding catch statement. 
This is achieved by creating a new error for each interruptible section, and
this error having a property that is checked in the catch statement. The error
is then rethrown if it is not caught by its owner. 
This is achieved as follows: 
%TC:ignore
\begin{lstlisting}[basicstyle=\small]
private class ATCInterrupt : Error
{
    Interruptible owner;
    this(Interruptible own)
    {
        super(null, null);
        owner = own;
    }
}

class Interruptible
{
    private ATCInterrupt error; 
    private void function() fn; 

    this(void function() func)
    {
        error = new ATCInterrupt(this); 
        fn = func
    }

    private ATCInterrupt caughtInt;

    void start()
    {
        try
        {
            fn();
        }
        catch (ATCInterrupt ex)
        {
            if (ex.owner != this)
                caughtInt = ex;
        }
        finally
        {
            if (!(caughtInt is null))
                throw caughtInt;
        }
    }
}
\end{lstlisting}
%TC:endignore
This example enables both the use of \texttt{Exception}s within the ATC region and
enables ATC sections to be nested inside each other. However, compared to the
\texttt{Thread} based approach, additional functionality is still required. 
For the safety of the system it must be possible to defer interrupts, enabling 
functions such as memory allocation or system calls to fully complete. In
Real-time Java, this is achieved through the use of runtime reflection to detect
whether the current function is safe to throw an \texttt{Exception} or not.
However, D does not have a concept of run-time reflection, and therefore this cannot be
used. 
Instead, there are two alternatives. For the first, the core runtime and standard
libraries would have to be modified. Through doing this, it is possible to
define a further function property, such as \texttt{@ATCDeferred}.  During these
sections of code, it would not be possible to interrupt. This
would be the preferred method of implementing ATC, as it would remove the
concern over safety from the developer. However, it would require significant
reworking of the D runtime, and possibly compiler alterations (as this would be
a language feature). As such, this method is outside of the scope of this
project. 
The alternative approach is to leave the safety of ATC to the developer by
providing methods to disable and re-enable deferral.
This can easily be achieved through the use of two boolean flags: one to keep track
of whether interrupts are deferred, and one to test whether an interrupt has
arrived while they have been deferred. 
However, as with the \texttt{Thread} approach, an extra method is then needed in 
order to guarantee fully safe execution during nested ATC sections. By keeping
track of each \texttt{Interruptible} section's parent, it is possible to defer
all interrupts, guaranteeing that no \texttt{Error} will be thrown. This is
achieved in the following manner: 
%TC:ignore
\begin{lstlisting}[basicstyle=\small]
class Interruptible
{
    ..
    void executeSafely(void delegate() fn) 
    {
        defer();
        scope(exit) restore();
        fn();
    }

    private bool previousDeferState;

    private void defer() @safe
    {
        if (! (parent is null) )
        {
            parent.defer;
        }
        previousDeferState = this.deferred;
        this.deferred = true;
    }

    private void restore() @safe
    {
        if (! (parent is null))
        {
            parent.restore;
        }
        this.deferred = previousDeferState;
    }
}
\end{lstlisting}
%TC:endignore
This can then be invoked in the same manner as the \texttt{Thread} based
implementation.
\par\bigskip\noindent
Furthermore, as with the implementation of \texttt{Thread} based ATC, a method 
of specifying cleanup is neeeded. This
is possible through the use of D's inbuilt \texttt{scope (exit)}.
This executes code specified on exiting the current scope, regardless of
whether this was through normal flow or as a result of an \texttt{Exception}. 
This provides a convenient method of adding cleanup. 
However, in order to keep the \texttt{Thread} and
\texttt{Exception} based approaches similar in terms of functionality, and to
allow the removal of these cleanup routines, the 
previously \texttt{addCleanup} and \texttt{removeCleanup} functions have
been added to the \texttt{Exception} model. 
\par\bigskip\noindent
As highlighted, there are two possible implementations of Asynchronous
Transfer of Control in D: a two-thread model and a Signal/Exception based
approach. Both of these methods meet all the desired requirements of ATC: 
they can be used safely; allow cleanup; they immediately transfer control; and
they abstract any unnecessary complexity away from the developer. 
However, some aspects of the two approaches differ. 
Using the \texttt{Thread} based approach, a new \texttt{Thread} is
created for each invocation. This suggests a heavier weight implementation compared
to the \texttt{Exception} model.
As far as the cancellation goes, there is little difference between
\texttt{pthread\textunderscore{}kill} and
\texttt{pthread\textunderscore{}cancel}:
both of these functions are operating system calls that use signals in their
implementation. 
However, the \texttt{Exception} based approach to ATC depends heavily on correct 
setup of the target \texttt{Thread's} stack when handling a signal. 
On different CPU architectures, it is possible that the signal handler may not 
allow propagation through the stack.
Therefore, in order to provide a generalisable means of performing ATC, both of
these methods have been implemented. 

\section{Requirement 9: Provision of Testing Facilities}
In order to verify the correct behaviour of the completed implementation, a set 
of tests have be provided. These tests allow a new system's viability 
to be tested and improve the maintainability of the system. D provides a built-in 
functionality for unit-testing: using the \texttt{unittest} flag, test code can 
be placed alongside function declarations. In addition, assert statements allow 
expected behaviour to be verified. 
This is shown in the following sample:
%TC:ignore
\begin{lstlisting}[basicstyle=\small]
int triple(int i) {
    return i*3; 
}
unittest {
    assert(triple(0) == 0); 
    assert(triple(-4) == -8); 
    assert(triple(10) == 20); 
    assert(12.triple == 36);
}
\end{lstlisting}
%TC:endignore
For testing, a compiler flag using the two most popular compilers, LDC and DMD, 
inserts any \texttt{unittest} code into the main function. A main function may 
also be artificially created through a compiler flag. This allows the 
full testing of library code through a compiler invocation in the following manner: 
%TC:ignore
\begin{lstlisting}[basicstyle=\small]
ldc -main -unittest -run realtime.d
\end{lstlisting}
%TC:endignore
This inbuilt definition of \texttt{unittest} allows unit-testing to occur 
without the need for tools external to the core language, thus providing a convenient 
and practical testing method. 
