% The Design and Implementation Section - plenty to discuss in here - how 
% each different part of the system has been designed and implemented, as well
% as what the original design aims were. 

%Formulate a moderate sized problem, to select and justify an appropriate approach, 
%and to follow the approach systematically. 
%Examined in the design/implementation chapters of the project. 

%Recognise alternatives, selecting and justifying the approach taken at each 
%point in the report, identifying parts of the project area that are feasible 
%within the time (etc) constraints of the project. Examined in the 
%design/implementation chapters of the project. 

%Appreciate the latent issues of the subject area (for example, in software 
%engineering they might meet and tackle such as emergent requirements, design 
%flaws, equipment/application problems). Examined in the project 
%design/implementation and evaluation chapters. 


% Word Count Estimate - 2500 Words

% \section{Design Aims} -- MAYBE DON'T NEED THIS BIT AS THE REQUIREMENTS ARE TO
% BE FORMULATED FROM THE LIT REVIEW SECTION 

% Using D Way that D works - hooks into C standard libraries in order to 
% provide support for things. 

% Targeting POSIX operating Systems - real time features, not many other OS 
% can do this. 

% Ability to target different compilers, not require custom runtimes. 
% GIVES THE ESSENTIAL - Program written with no knowledge of the Real-time
% systems additions I am creating will not be effected. This means support can 
% be added in through importing a library. 
In previous chapters,
existing real-time system programming languages have been examined in order to
define a set of required functionality. From this, a set of project requirements 
was determined. 
This chapter aims to describe the implementation of these requirements into the D
programming language, highlighting the completed implementations and any design 
decisions made along the way. 

\section{Implementation}

In this section, each of the functional requirements of the project the potential
implementations are discussed. This discussion will highlight any design 
decisions that have been made and will detail the completed implementation of 
each component. 

\subsection{Method of Provision}
% Library vs modified runtime ? 
For the end goal of this project to be usable, various methods for its delivery 
were considered. There are two significant alternatives. If no compiler, or 
core runtime features of the language need to be altered in order to provide the 
desired functionality then the project may be packaged as an external library. 
This is the most desirable end goal, hence the addition of requirement 8, as it 
prevents the need to provide and maintain a custom complier and runtime and enables 
exsiting D users to simply add-in the library as needed. 
Failing this, a modified runtime and/or compiler must be provided. This would 
enable the development of real-time systems, however, the modified system would 
require maintenance to keep it up to date with the core set of D functionality. 

\subsection{Requirement 1: Threads and Interprocess Communication}
D, being a C/C++ style language, provides support for the creation and use of 
threads. Threads in D follow a Java style approach: \texttt{Thread} is a class, 
allowing subclasses to be derived and methods to be overridden. The default 
class method will allow a function to be passed by reference and executed. 
These features can be seen in the example below, taken from the D website
\cite{core-thread}: 
\begin{lstlisting}
import core.Thread; 

class DerivedThread : Thread
{
    this()
    {
        super(&run);
    }
    private:
    void run()
    {
        // Derived thread running.
    }
}

void threadFunc()
{
    // Composed thread running.
}

// create and start instances of each type
void main()
{
    auto derived = new DerivedThread();
    auto composed = new Thread(&threadFunc);
    derived.start; 
    composed.start;
}
\end{lstlisting}
We can therefore see that D already provides 
concurrent control of system components, along with mechanisms for 
interprocess communication. However, the implementation is of interest: D 
provides an agnostic approach to the underlying operating system, supporting 
Windows, FreeBSD, OSX, Linux and Solaris. 
In order to provide support for this wide range of operating systems, the 
\texttt{Thread}
class contains operating system specific code, mapping down a standard interface 
onto various underlying implementations 
\cite{github-core-thread}. 
We are interested only in operating systems capable of meeting tight timing 
requirements in any calls to the kernel, and context switching.
As such, all additions made to D with regards to real-time applications are 
specifically targeted at POSIX compliant 
operating systems, in particular those with real-time extensions. 
\par\bigskip\noindent
It is worth noting that the underlying operating may require patching in order 
to be fully viable for a real-time system: system may not be fully
real-time compliant even if it is POSIX compliant. Because of this, real-time patches 
to the Linux kernel exist \cite{rt-wiki}. These enabling a greater 
guarantee over the timeliness of the kernel. 
Furthermore, special care must also be taken when developing such a system,
selecting appropriate hardware and programming the system in a manner appreciative 
of the underlying hardware \cite{rt-wiki-how-to}.

\subsection{Requirement 2: Priority Based Scheduling}
The ability to correctly schedule tasks or threads based on their priority is of 
critical importance to a real-time system. As previously discussed D provides 
concurrency through operating system Threads, encapsulated in the
\texttt{Thread} class. Additionally, the \texttt{Thread} class contains the 
parameter, \texttt{priority}. This parameter can be used to set or get a thread's 
priority \cite{core-thread}. 
However, in order for priority based scheduling to be used, this alone is not 
enough: the scheduler must be changed to function in a priority based manner. 
It was previously identified that D's threads provide a mapping onto an operating  
system thread, and hence it is the operating system scheduler that has to be set.  
However, no support exists within D's standard libraries to interact with the
scheduler. 
Therefore, this support has to be supplied. 
This can be achieved through interaction with C standard libraries, such as GlibC. 
The function sched\textunderscore{}setscheduler allows the operating system 
scheduler to be set to either SCHED\textunderscore{}FIFO or SCHED\textunderscore{}RR for 
this process \cite{sched-setscheduler}. 
In order to provide a more intuitive interaction a wrapper was written around the 
system call. This provides a more 'D like' interface, and enables a level of
abstraction to be taken from manually mapping D onto C for each application. 
\begin{lstlisting}[language=C++]
public import core.sys.posix.sched 
                : SCHED_FIFO, SCHED_OTHER, SCHED_RR; 

void setScheduler(int scheduler_type, int scheduler_priority)
{
    import core.sys.posix.sched 
                : sched_param, sched_setscheduler; 

    sched_param sp = { 
        sched_priority: scheduler_priority 
    }; 

    int ret = sched_setscheduler(0, scheduler_type, &sp); 
    if (ret == -1) {
        throw new Exception("scheduler did not properly set");
    }
}

void setFIFOScheduler(int schedPriority)
{
    setScheduler(SCHED_FIFO, schedPriority);
}

void setRRScheduler(int schedPriority)
{
    setScheduler(SCHED_RR, schedPriority); 
}
\end{lstlisting}
This can then be called in the following manner: 
\begin{lstlisting}
void main()
{
    setFIFOScheduler(50); 
}
\end{lstlisting}
The ability to set the scheduler to use a priority based method, combined with 
D language's previously present ability to set the priority of a thread therefore 
enables a priority based scheduling approach to be used.  

\subsection{Requirements 3 and 4: Monotonic Clocks and Absolute Sleep}
As mentioned in the previous section, it is a necessary feature of a real-time 
systems programming language to be able to sleep until an absolute time, rather 
than a relative time. In addition, this sleep must use a monotonic clock in order 
to remove any subjection from clock-drift or time-zone changes. D has support 
for a monotonic clock as part of the core libraries 
\cite{dlang-core-time}. We can access this using 
\texttt{MonoTime}. Unfortunately there is no ability to sleep until an 
absolute time. Using D's ability to interact with C libraries, it is possible 
to leverage GlibC's ability to perform this operation: the C function 
\texttt{clock\textunderscore{}nanosleep} allows an absolute time to be specified
\cite{clock-nanosleep}.
A wrapper function has been provided as part of the real-time library this 
project provides: \texttt{delayUntil}.
This function accepts the D type \texttt{MonoTime} as an input, converts it to the C 
equivalent, and calls the C function \texttt{clock\textunderscore{}nanosleep}, 
allowing an absolute delay. The code is displayed below: 
\begin{lstlisting}
void delayUntil(MonoTime timeIn)
{
    import core.sys.linux.time; 
    import core.time : Duration, timespec; 
    Duration dur = timeIn - MonoTime(0) ;
    long secs, nansecs; 
    dur.split!("seconds", "nsecs")(secs, nansecs); 
    timespec sleep_time = timespec(secs, nansecs); 
    if (clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, 
                                    &sleep_time, null)) {
        throw new Exception("Failed to sleep as expected!"); 
    }
}
\end{lstlisting}
This allows simplistic use from a real-time application. An absolute sleep can 
be performed in the following manner: 
\begin{lstlisting}
void main()
{
    auto time = MonoTime.currTime(); 
    time += 3.seconds; 
    delayUntil(time);
}
\end{lstlisting}
As such, the D programming language can easily provide the ability to sleep 
until an absolute time. In order to easily the use of this functionality, a 
wrapper has been provided, giving an interface to D.

\subsection{Requirements 5 and 6: Bounded Priority Inversion}
In D, Mutexes follow a similar approach to Threads: the language's
implementation provides a wrapper around operating system calls, this 
enables operating system independent code to be written simply. However, D has no 
inherent ability to provide priority inversion handling protocols. 
\par\bigskip\noindent
Due to the underlying implementation of D's mutexes, there are two alternative 
approaches to defining the priority inheritance and priority ceiling protocols: 
either the current implementation may be extended to incorporate system calls 
setting the POSIX mutexes as using these protocols, or a new, language level 
mutex can be added that defines these protocols. As real-time systems have been 
shown to only be viable on operating systems that are POSIX compliant, and due to 
the quantity of work involved in reimplementing and defining these protocols, the 
decision was made to use POSIX mutexes. 
\par\bigskip\noindent
It is worth noting that the priority inheritance and priority ceiling protocols 
are available when using POSIX mutexes in C. 
\cite{mutex-setprotocol}. However, even though D's implementation of the \texttt{Mutex} 
class uses POSIX mutexes, it does not not set the protocol during their creation. 
As requirement 8 highlights the importance of an unmodified runtime, the 
constructor for this class cannot be extended, instead it must be fully 
reimplemented with an alterative imlpmentation of the constructer adding in 
the C function \texttt{pthread\textunderscore{}mutexattr\textunderscore{}setprotocol} \cite{mutex-setprotocol}. 
The full implementation of this mutex class is defined:
\lstinputlisting[language=Java]{rtmutex.d}
A mutex created like this may then be initialised in the following manner: 
\begin{lstlisting}
auto a = new RTMutex(PRIORITY_INHERIT);
\end{lstlisting}
However, this is not a very D-like implementation. As with the scheduler calls, 
it is better to wrap this into two separate constructors. Additionally, support 
is needed to set and receive the priority ceiling associated with the 
mutex. This is achieved in a similar manner: additional 
functions can be added providing a wrapper around the C functions 
\texttt{pthread\textunderscore{}mutex\textunderscore{}getprioceiling} and 
\texttt{pthread\textunderscore{}mutex\textunderscore{}setprioceiling}.
All the above can be achieved through a dummy class, in the following manner: 
\begin{lstlisting}
class CeilingMutex 
{
    private import core.sync.exception : SyncError;
    alias ceilingMutex this;
    RTMutex ceilingMutex;

    // Initializes a new CeilingMutex
    this()
    {
        ceilingMutex = new RTMutex(PROTOCOL_CEILING);
        this.ceiling = 1;
    }

    final @property int ceiling()
    {
        int ceiling; 
        if(pthread_mutex_getprioceiling(this.handleAddr, 
                                                &ceiling))
            throw new SyncError("Unable to fetch the priority 
                           ceiling for the associated Mutex"); 
        return ceiling; 
    }

    final @property void ceiling(int val)
    {
        if(pthread_mutex_setprioceiling(this.handleAddr, 
                                                val, null))
            throw new SyncError("Unable to set the priority 
                           ceiling for the associated Mutex"); 
    }
}
\end{lstlisting}
This allows the priority ceiling to be set or get as if it were a property of 
the \texttt{RTMutex} class. Similarly, the functions defined in \texttt{RTMutex} 
can be accessed as though they were part of the \texttt{CeilingMutex} class. 
A similar result is achieved for the \texttt{InheritanceMutex} class.
This allows a very idiomatic and readable interaction: 
\begin{lstlisting}
auto a = new CeilingMutex;
a.ceiling = 50; 
writeln("priority ceiling of a is: ", a.ceiling); 
synchronized(a) 
{
    // do something
}
\end{lstlisting}
Therefore, on a POSIX compliant operating system, the ability to interact with 
existing C libraries enables an implementation of a mutex, similar to the languages 
core model, to be extended, incorporating both the priority inheritance and 
priority ceiling protocols. Wrappers around this \texttt{RTMutex} class for 
either protocol, and around the C functions 
\texttt{pthread\textunderscore{}mutex\textunderscore{}setprioceiling} 
and \texttt{pthread\textunderscore{}mutex\textunderscore{}getprioceiling{}} 
provide an easy to use and intuitive implementation. 

\subsection{Requirement 7: Asynchronous Transfer of Control} % 600 words
The final primitive required for a programming language to support the development 
of a real-time system is the ability to perform an asynchronous transfer of 
control. This entails providing a section of code that can be interrupted at 
any moment in time asynchronously.
As detailed in the previous section, there are several different methods of 
achieving this aim. Here, each method is considered, and the logic behind the 
implementation explained. 
\subsubsection*{Setjmp and Longjmp} 
Through D's interaction with C, asynchronous transfer of control can be achieved 
through use of the commands, \texttt{setjmp} and \texttt{longjmp}. These allow 
the control of flow to be altered in a program by marking a location in code when 
\texttt{setjmp} is called, and jumping to this saved location when \texttt{longjmp} 
is called. It is possible to asynchronously invoke the \texttt{longjmp} function
through the use of POSIX signals, and a signal handler. This allows an asynchronous 
signal to effect the flow of control. However, due to the lack of concern for 
stack management, it is common for the stack to become corrupted using this approach
\cite{unwinding-stack}. As ATC will typically involve altering the current function, 
it is likely to affect the stack, and such would not provide a memory safe 
implementation in D. 

\subsubsection*{Thread Cancellation}
\subsubsection*{Exceptions and Signals}

An alternative approach is to set a thread's cancellation type using to 
\texttt{PTHREAD\textunderscore{}CANCEL\textunderscore{}ASYNCHRONOUS} using 
\texttt{pthread\textunderscore{}setcanceltype}. This then allows a thread to 
be asynchronously cancelled using \texttt{pthread\textunderscore{}cancel}. Cleanup 
is also possible using this mechanism through the use of 
\texttt{pthread\textunderscore{}cleanup\textunderscore{}pop}. However, 
this method is complicated to implement, requiring a thread to resume from an 
arbitrary point after its cancellation. In addition, this becomes further 
complicated by the desire to nest interruptible sections of code. 
Ada takes a similar approach to this, using a multi-threaded model. 
\par\bigskip\noindent
An alternative approach is use the inbuilt Exception/Error handling mechanisms 
that D provides, throwing an Error when an asynchronous signal is received and 
catching that error when leaving the interruptible section. This can be 
achieved through having explicit methods such as \texttt{enableAsynchronousInterrupts()}
and \texttt{disableAsynchronousInterrupts()}. However, this can lead to error 
prone programs, where \texttt{enableAsynchronousInterrupts()} is called and not 
followed later by a call to \texttt{disableAsynchronousInterrupts()}. 
In addition, this does not permit the ability to nest interruptible sections. 

\subsection{Requirement 9: Provision of Unit Tests}

\subsection{Requirement 10: Documentation of the Library}
