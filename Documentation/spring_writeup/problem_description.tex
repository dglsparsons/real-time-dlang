%Problem description and analysis for my project. 
% Word Count Guide - 1500 words.

This chapter aims to examine the Literature Review in order to provide a set of 
requirements for real-time programming. Following this, it will set out a 
description of the features of the D programming language, discussing its 
suitability for the development of real-time systems.

\section{Requirements}
The Literature Review highlighted a set of target criteria for real-time 
programming. These are summarised below. Furthermore, additional desired features 
are defined in this section. 
\begin{table}[!h]
\centering
\begin{tabular}{|L{0.2\linewidth}|L{0.75\linewidth}|}
\hline
\textbf{Requirement Number} & 1 \\ \hline
\textbf{Requirement} & \emph{The ability to provide concurrent programming through a 
mechanism such as Java's} \texttt{Thread}\emph{, or Ada's} \texttt{Task}. \\ \hline
\textbf{Rationale}      & Provides separation of concerns between separate components
and provides control over concurrent operations. \\ \hline
\textbf{Criterion}      & New threads of control can be created through a defined 
function. \\ \hline
\textbf{Importance}     & Necessary \\ \hline
\end{tabular}
\end{table}
\begin{table}[!h]
\centering
\begin{tabular}{|L{0.2\linewidth}|L{0.75\linewidth}|}
\hline
\textbf{Requirement Number} & 2 \\ \hline
\textbf{Requirement} & \emph{The ability to schedule concurrent threads based on 
                their priority.}\\ \hline
\textbf{Rationale}      & High criticality tasks or those with a short deadline
                must be given a high priority, enabling them to meet their 
                deadlines. \\ \hline
\textbf{Criterion}      & Provided functions must allow the scheduler and
                priority to be changed. \\ \hline
\textbf{Importance}     & Necessary \\ \hline
\end{tabular}
\end{table}
\begin{table}[!h]
\centering
\begin{tabular}{|L{0.2\linewidth}|L{0.75\linewidth}|}
\hline
\textbf{Requirement Number} & 3 \\ \hline
\textbf{Requirement} & \emph{Access to a monotonic clock.} \\ \hline
\textbf{Rationale}      & Provides consistent, precise timing requirements. \\ \hline
\textbf{Criterion}      & A function must allow a time value to be read from a monotonic
                clock. \\ \hline
\textbf{Importance}     & Necessary \\ \hline
\end{tabular}
\end{table}
\begin{table}[!h]
\centering
\begin{tabular}{|L{0.2\linewidth}|L{0.75\linewidth}|}
\hline
\textbf{Requirement Number} & 4 \\ \hline
\textbf{Requirement} & \emph{An absolute sleep statement.} \\ \hline
\textbf{Rationale}      & Relative sleep statements are subject to preemption and may not 
                provide precise timings. \\ \hline
\textbf{Criterion}      & A function must delay the calling thread until an absolute time. \\ \hline
\textbf{Importance}     & Necessary \\ \hline
\end{tabular}
\end{table}
\begin{table}[!h]
\centering
\begin{tabular}{|L{0.2\linewidth}|L{0.75\linewidth}|}
\hline
\textbf{Requirement Number} & 5 \\ \hline
\textbf{Requirement} & \emph{The Immediate Priority Ceiling
Protocol.} \\ \hline
\textbf{Rationale}      & Limits the blocking a task may suffer.  \\ \hline
\textbf{Criterion}      & The ability to specify a mutex using the protocol.\\ \hline
\textbf{Importance}     & Necessary \\ \hline
\end{tabular}
\end{table}
\begin{table}[!h]
\centering
\begin{tabular}{|L{0.2\linewidth}|L{0.75\linewidth}|}
\hline
\textbf{Requirement Number} & 6 \\ \hline
\textbf{Requirement} & \emph{The Priority Inheritance Protocol.}\\ \hline
\textbf{Rationale}      & Limits the blocking a task may suffer. \\ \hline
\textbf{Criterion}      & The ability to specify a mutex using the protocol\\ \hline
\textbf{Importance}     & Necessary \\ \hline
\end{tabular}
\end{table}
\begin{table}[!h]
\centering
\begin{tabular}{|L{0.2\linewidth}|L{0.75\linewidth}|}
\hline
\textbf{Requirement Number} & 7 \\ \hline
\textbf{Requirement} & \emph{Asynchronous Transfer of Control (ATC).} \\ \hline
\textbf{Rationale}      & Real-time systems require ATC for a wide range of functionality, 
                including timing out computations, cancelling overrun deadlines,  
                or instantaneous mode changes of a system. \\ \hline
\textbf{Criterion}      & The ability to enter an abortable section of code and
                safely abort the code. \\ \hline
\textbf{Importance}     & Necessary \\ \hline
\end{tabular}
\end{table}
\begin{table}[!h]
\centering
\begin{tabular}{|L{0.2\linewidth}|L{0.75\linewidth}|}
\hline
\textbf{Requirement Number} & 8 \\ \hline
\textbf{Requirement} & \emph{No modifications to the language's compiler or
core libraries.} \\ \hline
\textbf{Rationale}      & Provides a more accessible system and simplifies the  
                process of developing real-time systems in D. 
                Maintains compatibility with existing D code. \\ \hline
\textbf{Criterion}      & For programming real-time systems in D, a standard compiler and  
                an unmodified runtime may be used. \\ \hline
\textbf{Importance}     & Desired \\ \hline
\end{tabular}
\end{table}
\begin{table}[!h]
\centering
\begin{tabular}{|L{0.2\linewidth}|L{0.75\linewidth}|}
\hline
\textbf{Requirement Number}   & 9 \\ \hline
\textbf{Requirement} & \emph{Provision of tests for the provided library.} \\ \hline
\textbf{Rationale}      & Allows an easier checking of the viability of  
                real-time features. Aids debugging in any future 
                modifications to the feature-set. \\ \hline
\textbf{Criterion}      & A set of unit-tests that ensure correct behaviour of the system. \\ \hline
\textbf{Importance}     & Desired \\ \hline
\end{tabular}
\end{table}
\begin{table}[!h]
\centering
\begin{tabular}{|L{0.2\linewidth}|L{0.75\linewidth}|}
\hline
\textbf{Requirement Number} & 10 \\ \hline
\textbf{Requirement} & \emph{Provision of documentation, showing typical use cases for provided 
                functionality and describing its usage.} \\ \hline
\textbf{Rationale}      & Allows potential users to understand the purpose and 
                functionality provided. \\ \hline
\textbf{Criterion}      & All functions and common interactions must be well documented. \\ \hline
\textbf{Importance}     & Desired \\ \hline
\end{tabular}
\end{table}
\FloatBarrier
\section{Features of the D Programming Language}
As mentioned in the introduction, the D programming language has many 
characteristics that lend it to the development of real-time systems.
These are outlined in further detail in this section. 
However, D also has certain characteristics that are less suitable for 
real-time systems, such as the use of a garbage collector. 
These features are similarly detailed.

\subsection{High and Low-Level}
% Aims to achieve everything that is possible with other languages such as C++
% Contains high level abstractions
The D programming language is primarily inspired by C++, aiming to be a ``C++ done
right'' 
\cite{qznc-tutorial}. 
This explains the power that the language possesses. D is a high level, compiled 
language with support for object oriented programming. In addition, D boasts 
native efficiency: as with C and C++, there is no virtual 
machine hosting the language's environment.
Furthermore, D aims to provide
powerful abstractions that aid in the speed and ease of development of general systems. 
The following code example, taken from dlang.org, cleanly and efficiently 
sorts lines of a file and outputs them. 
\begin{lstlisting}[basicstyle=\small]
import std.stdio, std.array, std.algorithm;

void main()
{
    stdin
        .byLineCopy
        .array
        .sort
        .each!writeln;
}
\end{lstlisting}
However, in addition to providing high-level abstractions, D maintains low-level 
capabilities: the language retains access to inline assembler, system calls, 
interrupts, and low level I/O.
\par\bigskip\noindent
This flexibility of D is one of its greatest advantages. It ``allows its user to tap 
into a wide range of programming techniques, without throwing too many 
idiosyncrasies in the way'' \cite{ddili-book}. 
These features also make D well suited to the development of real-time systems: 
as stated in the Literature Review, the ability to program sporadic tasks
may depend on the ability to handle interrupts in a timely and predictable manner.
Furthermore, the ability to perform IO operations using hardware allows the
system to interact with special purpose hardware, another crucial feature of
real-time systems.
D's multipurpose approach therefore allows the language to handle low-level concerns,
while simultaneously benefiting from code that can be aggressively optimized by the
compiler \cite{dlang-overview}, whilst also maintaining a readable and user-friendly
syntax.

\subsection{Concurrency}
D is often referred to as a language that implements the message passing model 
of concurrency \cite{ddili-book}. D's message passing API 
allows asynchronous messages to be transferred between threads of control using 
message boxes. This allows a high-level of abstraction and provides an 
interface that is simplistic to use. However, it is also misleading: the underlying 
model of D uses the more typical lock and mutex approach 
\cite{dlang-github-mutex}, 
with the message passing interface simply built on top of this 
\cite{dlang-github-concurrency}. 
As such, when developing in D, the programmer has the option to choose between 
the higher level message passing interface or the lower level lock and mutex 
approach. A mixed approach can even be taken, using both. 
\par\bigskip\noindent
D also has an interesting approach to sharing memory between threads. 
Global variables are \emph{not} shared between different threads by default, as 
they are in other languages. Instead, each thread has a local copy of the global variable. 
This is a concept that is known as Thread Local Storage (TLS) 
\cite{migrate-to-shared}. 
If global resources are to be shared between different threads, D provides a way of 
achieving this: the \texttt{shared} and
\texttt{\textunderscore{}\textunderscore{}gshared} keywords.
\par\bigskip\noindent
The core runtime for D provides an additional interesting feature: an atomicop 
library \cite{core-atomic}. 
This provides a mechanism for some degree of sharing to be performed without the 
need for locks, allowing many operations to be performed indivisibly.

\subsection{Memory Safe Programming}
An area of particular interest to real-time systems is the notion of memory 
safe programming. In addition to providing powerful inbuilt types such as arrays 
in D, the D compiler also implements range checking and numerous other 
safety checks on compilation, preventing any undefined behaviour.
Additional safety features are also provided in the SafeD subset of the language
\cite{safe-d}. The SafeD subset will only allow functions to perform 
operations that are deemed as either safe or trusted, preventing any 
potential memory corruption. Examples of unsafe functions could include the 
manual manipulation of pointers or the use of unsafe types. A major difference 
with regards to other languages is that D provides sufficient power for many complex 
operations to be performed, whilst maintaining safety.

\subsection{Garbage Collector}
Coupled with the safety of the SafeD subset, D provides additional memory
safety through its use of a garbage collector. This
automatically manages heap allocated memory. 
However, this safety comes at a cost. One significant problem with developing a 
real-time system in D is the need to bypass D's garbage collector. 
The current implementation of the garbage 
collector is a `stop the world' approach: when garbage collection is occurring, 
all threads are halted from making progress 
\cite{dlang-garbage}. A real-time system must be able
to guarantee a maximum response time on any operation performed, 
where predictable behaviour is fundamental to this; 
with a stop the world garbage collector, this behaviour cannot be guaranteed. 
\par\bigskip\noindent
One possible solution to this problem is to disable the garbage collector for 
real-time applications. This is possible to do by marking functions \texttt{@nogc}, 
or by calling \texttt{GC.disable()}. However, this is not without drawbacks: 
many of D's higher level features and libraries rely on garbage collection. 
Another possibility is to replace D's garbage collector with a real-time 
one. This would provide the necessary predictable behaviour. 
However, due to the amount of further work required, tackling the issue of the garbage 
collector is outside the scope of this project.
A third possibility of avoiding the garbage collector comes in through
detaching \texttt{Threads} from D's runtime. This prevents the garbage collector from
pausing their execution. However, any garbage collected objects used must be registered
by another \texttt{Thread} within the runtime to prevent their collection. 
The final possibility is to preallocate all memory that could be needed. This 
prevents applications from requesting more memory during their execution, and 
thus prevents garbage collection. 

\subsection{Additional Interesting Features}
% Idea of built in tests, contract programming, error handling
Another unique feature of D is the ability to build unit-tests into a 
program without the need for external libraries: D provides support for 
unit-testing, complete with coverage analysis, as a language feature. 
\par\bigskip\noindent
In addition, D provides a Java style model for exceptions and errors, enabling 
a much simpler error handling system than the C style ERRNOs 
\cite{ddili-book}. 
These exceptions are functionally very similar to Java exceptions. Compared to
C++'s exception model, D throws exceptions through reference, instead of by
value \cite{interface-to-cpp}. 

\section{Analysis of Target Criteria} 
This section aims to outline the functional requirements of the project,
offering a brief discussion of any potential implementations.

\subsection{Requirements 1 and 2: Concurrency and Priority Scheduling} %100
The previous chapters detailed how real-time systems require concurrent control
over system components. In D, this can be achieved through its \texttt{Thread} class. 
\par\bigskip\noindent
However, requirement 2 shows that priority scheduling is also required for a
real-time system. 
In D, \texttt{Threads} exist in kernel space. Therefore, in order to
provide priority based scheduling, the system's scheduler requires changing. Burns
and Wellings show that there are several different scheduling algorithms that
may be used in real-time systems \cite{real-time-systems}. It is worth noting
that of all the operating systems on which D runs, only those that are POSIX
compliant are capable of handling priority scheduling. Furthermore, for a
real-time system, this operating system must be a real-time operating system.
This provides a limitation on the project: D can only be programmed in a real-time
capable manner on a real-time POSIX operating system. 
By default, D is provided with no method to change the underlying operating
systems scheduler. 
The ability to adjust the scheduler to use either a round-robin or FIFO approach 
is therefore a desired end-goal of the project.

\subsection{Requirements 3 and 4: Monotonic Clocks and Absolute Sleep} 
As described in the Literature Review chapter, access to both a high precision
clock and absolute sleep method is necessary for a real-time system. D's
current implementation can access a high precision clock through the use of
functionality provided in the core runtime \cite{dlang-core-time}. However,
access to an absolute sleep function is absent. Instead, D's default
\texttt{sleep}
method maps onto the C relative sleep function, \texttt{nanosleep}. There are
therefore two possible alternative implementations. Either the call to
\texttt{nanosleep} could be wrapped in such a manner that it is not possible to be preempted, 
or the C function, \texttt{clock\textunderscore{}nanosleep}, may be used. This function enables 
an absolute sleep with a user specifiable clock \cite{clock-nanosleep}. 

\subsection{Requirements 5 and 6: Bounded Priority Inversion} %100
In order to achieve a bound on the amount of priority inversion that a task
might suffer, two alternative protocols exist: the Priority Inheritance protocol and the
Priority Ceiling protocol. D's implementation of a \texttt{Mutex} currently
implements neither protocol and is therefore not suitable for real-time systems.
As with the \texttt{Thread} class, the languages \texttt{Mutex} class provides 
a wrapper on POSIX mutexes \cite{dlang-github-mutex}. 
The POSIX specification of mutexes states that
they can implement the priority ceiling or the priority inheritance protocol 
\cite{mutex-setprotocol}. Therefore, there are two possible ways of
implementing these protocols in D: 
the appropriate C functions can be imported, allowing the
use of POSIX mutexes with a specified protocol; or the protocol itself may be
implemented on top of the existing \texttt{Mutex} class. 

\subsection{Requirement 7: Asynchronous Transfer of Control} %100
Asynchronous Transfer of Control (ATC) is a difficult feature to implement due to
its ``methodologically suspect'' nature \cite{Brosgol:2002:ATC}. There are
three alternative implementations. In C, ATC can be simulated using the
\texttt{setjmp} and \texttt{longjmp} instructions, coupled with a signal
handler. In Ada, a
two-threaded model is often used. This functions by blocking the calling task
on a condition, while a subsidiary task is created to execute the abortable
code. In Java, an exception based approach uses the \texttt{interrupt}
method to asynchronously throw an exception in the target \texttt{Thread}. 
As D has the ability to interact with C code, \texttt{setjmp} and \texttt{longjmp} may be
used. Furthermore, its model of \texttt{Threads} allows a cancellation based
approach to be taken. Finally, D has a similar model of exceptions to Java. By
combining D's exception model with POSIX signals, D therefore has the potential 
to implement any of the three approaches.
