%Problem description and analysis for my project. 

% Word Count Guide - 1500 words.


\section{Features of the D Programming Language}
As mentioned in the introduction, the D programming language has many 
characteristics that lend it nicely to the development of real-time systems.
These are outlined in further detail in this section. 
However, D also has certain features that are less desirable for a real-time 
system, such as the use of a garbage collector. These less desirable features 
are also detailed in this section.


\subsection{High and Low-Level}
% Aims to achieve everything that is possible with other languages such as C++
% Contains high level abstractions
The D programming language is primarily inspired by C++, aiming to be a ``C++ done
right'' 
\cite{qznc-tutorial}. This explains the 
power that the language possesses: D is primarily a high level language, with
a large number of abstractions that aid in the speed and ease of development. 
%TODO - EASE OF DEVELOPMENT OF WHAT.
However, D still maintains low level capabilities: the language still has access 
to inline assembler, system calls, interrupts, and low level I/O in addition to 
being a compiled language.
\par\bigskip\noindent
The flexibility of D is one of its greatest advantages. It ``allows its user to tap 
into a wide range of programming techniques, without throwing too many 
idiosyncrasies in the way''
\cite{ddili-book}, 
while simultaneously generating code that can be aggressively optimized by the
compiler 
\cite{dlang-overview}. D maintains a readable syntax, and 
user-friendly approach to development, making it a powerful and highly capable 
language.

\subsection{Memory Safe Programming}
% Concept of memory safe programming that D supports.
An area of particular interest to real-time systems is the notion of memory 
safe programming. In addition to providing powerful inbuilt types such as arrays 
in D, the D compiler also implements range checking and numerous other 
safety checks on compilation, preventing any undefined behaviour from occurring.
Additional safety features are also provided in the SafeD subset of the language
\cite{safe-d}. The SafeD subset will only allow functions to perform 
operations that are deemed as either safe or trusted, preventing any 
potential corruption of memory. Examples of unsafe functions could include the 
manual manipulation of pointers, or the use of unsafe types. A major difference 
with regards to other languages is that D provides sufficient power so that many complex 
operations can be performed and used, while still remaining completely safe.

\subsection{Concurrency}
%Message passing
D is often referred to as a language that implements the message passing model 
of concurrency, rather than the more standard Lock and Mutex approach 
\cite{ddili-book}. D's message passing API 
allows asynchronous messages to be transferred between threads of control using 
message boxes. This allows a high-level of abstraction and provides an 
interface that is simplistic to use. However, it is also misleading: the underlying 
model of D uses the more typical lock and mutex approach 
\cite{dlang-github-mutex}, 
with the message passing interface simply built on top of this 
\cite{dlang-github-concurrency}. 
As such, when developing in D, the programmer has the option to choose between 
the higher level message passing interface or the lower level lock and mutex 
approach. It is even true that the two can both be used, taking a mixed approach. 
\par\bigskip\noindent
D also has an interesting approach to sharing memory between threads. In D 
global variables are not shared between threads of control, as they are in 
other languages. Instead, each thread has a local copy of the global variable. 
This is a concept that is known as Thread Local Storage (TLS) 
\cite{migrate-to-shared}. 
If resources are to be shared between different threads, D provides a way of 
achieving this: the \texttt{shared} and \texttt{\_\_gshared} keywords. In addition, 
\texttt{immutable} variables are shared by default. 
\par\bigskip\noindent
The core runtime for D provides an additional interesting feature: an atomicop 
library 
\cite{core-atomic}. 
This provides a mechanism for some degree of sharing to be performed without the 
need for locks, allowing many operations to be performed indivisibly.


\subsection{Garbage Collector}
%GC
One significant problem with developing a real-time system in D is the need to 
overcome D's garbage collector. The current implementation of the garbage 
collector is a `stop the world' approach: when garbage collection is occurring, 
all different threads are halted from making progress 
\cite{dlang-garbage}. This causes problems with 
real-time systems. A real-time system must be able to guarantee a maximum response 
time on any operation performed, predictable behaviour is therefore fundamental to this. 
With a stop the world garbage collector, such behaviour cannot be guaranteed. 
\par\bigskip\noindent
One possible solution to this problem is to disable the garbage collector for 
real time applications. This is possible to do by marking functions \texttt{@nogc}, 
or by calling \texttt{GC.disable()}. However, this is not without drawbacks: 
many of D's higher level features and libraries use garbage collection. 
%TODO - An alternative approach, i.e detaching a thread from the runtime
Another possibility is to replace D's garbage collector with a real-time 
garbage collector. This would provide realiable behaviour, thus preventing these 
issues. However, 
due to the amount of further work required, tackling the issue of the garbage 
collector is outside the scope of this article.

\subsection{Additional Interesting Features}
% Idea of built in tests, contract programming, debugging, error handling
Another unique feature of D is the ability to build unit tests into a 
program without the need for external libraries: D provides support for 
unittesting as a language feature. 
\par\bigskip\noindent
In addition, D provides a Java style model for Exceptions and Errors, enabling 
a much simpler error handling system than the C style ERRNOs 
\cite{ddili-book}. 
%TODO - Compare with C++ exceptions.






\section{Features of a Real-time System}
% Problem Description / Analysis of components that are needed in order to 
% constitute a Real-time system. 


In order to supply support for programming real-time systems, we must first 
consider the characteristics of a real-time system. This section aims to outline
any necessary primitives for a programming language, explaining why they are 
necessary. 

\subsection{Threads and Interprocess Communication}
Real-time systems are inherently parallel. They are concerned heavily with 
the notion of timing and scheduling many different components across a system. 
The ability to schedule these components in isolation through the medium 
of threads therefore provides a valuable tool in reducing the complexity in 
constructing the system and additionally increases the readability of the 
final system 
\cite[p132]{real-time-systems}. It is therefore a requirement of a real-time systems 
programming language to provide support for an abstraction into isolating 
concurrent events and their control into separate entities. 
In Java and 
C with POSIX threads, this concurrency mechanism is provided by threads or processes. 
In Ada this mechanism is provided by Tasks 
\cite[p251]{gehani1989concurrent}.

\subsection{Priority Scheduling}
In addition to the creation and isolation of processes through the use of 
threads, it is a requirement of real-time systems 
that control over their scheduling is provided. 
While many algorithms exist that enable real-time systems to be scheduled, such 
as earliest deadline first (EDF), priority based scheduling approaches are the 
most commonly used
\cite{real-time-systems}. 
It is therefore a requirement of the programming language to provide support 
for a priority based scheduling algorithm or allowing the scheduler to be 
selected. Additional complication is introduced when we consider if scheduling 
is the domain of the programming language or of the operating system:
threads may be either language controlled or operating system controlled. 
If threads are language controlled, then it is necessary to provide 
language functionality enabling threads to have priorities and scheduling threads 
based on their priority.
If the threads are operating system controlled, then the language needs 
support for interacting with the underlying operating system in order to 
adjust the scheduler. 

\subsection{Bounded Priority Inversion}
When using shared resources in a priority based system it is possible for 
a high priority task to become blocked from making progress due to a low
priority task holding a resource. Additionally, the low priority task may be 
preempted and prevented from making progress. In this instance, the high priority task is 
effectively running at the lowest priority of the system: it has to wait for all other 
tasks to complete before it can progress. This is a well studied phenomenon known 
as priority inversion 
\cite{real-time-systems}. 
In order to provide a reliable response in a priority based system, it is 
therefore necessary that priority inversion is bounded.
Two main protocols exist that solve this problem: the priority inheritance protocol 
and the priority ceiling protocol. Each protocol has its own respective 
strengths and weaknesses, but enable reliable behaviour of the system 
\cite{mall2009real}.
It is therefore a requirement of a real-time systems programming language 
that the underlying data sharing system is not subject to unbounded priority 
inversion: the ability to specify the use of either the priority inheritance 
protocol or the priority ceiling protocol is a necessary feature.  

\subsection{Monotonic Clocks and Absolute Sleep}
%TODO - fix this section
In general programming, when a worker thread has no computation to be 
performing, a call is made to a sleep method. This will cause the thread
to hand over any computation resources for a defined period of time. In a 
real-time system however, we often require fine-grained control of exactly
when a thread will awaken. The typical approach involving a relative sleep 
time can be imprecise due to preemption. In order to achieve a predictable 
sleep function, as required in a real time system, it is therefore necessary 
to have the ability to wait until an absolute time. Further complication 
occurs with the definition of time: many implementations of time are subject 
to phenomena such as daylights savings time or leap seconds. 
In order to counteract these, a Monotonic clock must be used. This ticks at a 
predefined constant rate, giving predictable behaviour. 

\subsection{Asynchronous Transfer of Control}
Asynchronous Transfer of Control (ATC) is a controversial topic with regards to its 
implementation in many languages, yet it is deemed a useful, if not necessary 
feature of a real-time system 
\cite{atc-article}. ATC is the transfer 
of control within a thread, that has been triggered by an external event or thread, 
its effect may be instantaneous, or deferred until a safe section has been reached. 
In addition, sections of code susceptible to ATC may be nested, causing a 
complex problem in terms of semantics, methodology, and implementation. 
However, the use of ATC extends to many purposes such as low latency responses to events, timing 
out a thread of computation, or terminating threads, making it an invaluable feature. 
