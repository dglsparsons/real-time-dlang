%Problem description and analysis for my project. 
% Word Count Guide - 1500 words.

This chapter aims to set out a description of the features of the D
programming language, before analysing the target criteria of this project.
For each goal, this chapter will offer a discussion on how it might be 
implemented in D.

\section{Features of the D Programming Language}
As mentioned in the introduction, the D programming language has many 
characteristics that lend it nicely to the development of real-time systems.
These are outlined in further detail in this section. 
However, D also has contains certain characteristics that are less desirable for 
real-time systems, such as the use of a garbage collector. 
These less desirable features are similarly detailed in order to highlight the 
shortcomings of D. 

\subsection{High and Low-Level}
% Aims to achieve everything that is possible with other languages such as C++
% Contains high level abstractions
The D programming language is primarily inspired by C++, aiming to be a ``C++ done
right'' 
\cite{qznc-tutorial}. 
This explains the power that the language possesses. D is a high level, compiled 
language with support for object oriented programming. In addition, D boasts 
native efficiency: as with C and C++, there is no virtual 
machine hosting the languages environment and causing additional overhead. 
Furthermore, D aims to provide
powerful abstractions that aid in the speed and ease of development of general systems. 
The following code example, taken from dlang.org, cleanly and efficiently 
sorts lines of a file and outputs them. 
\begin{lstlisting}
import std.stdio, std.array, std.algorithm;

void main()
{
    stdin
        .byLineCopy
        .array
        .sort
        .each!writeln;
}
\end{lstlisting}
However, in addition to providing high-level abstractions, D maintains low 
level capabilities: the language still retains access to inline assembler, 
system calls, interrupts, and low level I/O.
\par\bigskip\noindent
This flexibility of D is one of its greatest advantages. It ``allows its user to tap 
into a wide range of programming techniques, without throwing too many 
idiosyncrasies in the way'' \cite{ddili-book}. 
These features also make D well suited to the development of real-time systems, 
as stated in the literature review, the ability to program sporadic tasks
may depend on the ability to handle interrupts in a timely and predictable manner.
Furthermore, the ability to perform IO operations using hardware allows the
system to interact with special purpose hardware, another crucial feature of
real-time systems.
D's multipurpose approach therefore allows the language to handle low-level concerns,
while simultaneously benefiting from code that can be aggressively optimized by the
compiler \cite{dlang-overview}, maintaining a readable and user-friendly
syntax. D is therefore a powerful and highly capable language.

\subsection{Concurrency}
%Message passing
D is often referred to as a language that implements the message passing model 
of concurrency, rather than the more standard lock and mutex approach 
\cite{ddili-book}. D's message passing API 
allows asynchronous messages to be transferred between threads of control using 
message boxes. This allows a high-level of abstraction and provides an 
interface that is simplistic to use. However, it is also misleading: the underlying 
model of D uses the more typical lock and mutex approach 
\cite{dlang-github-mutex}, 
with the message passing interface simply built on top of this 
\cite{dlang-github-concurrency}. 
As such, when developing in D, the programmer has the option to choose between 
the higher level message passing interface or the lower level lock and mutex 
approach. It is even true that a mix approach can be taken, using both.
\par\bigskip\noindent
D also has an interesting approach to sharing memory between threads. In D 
global variables are not shared between different threads as they are in 
other languages. Instead, each thread has a local copy of the global variable. 
This is a concept that is known as Thread Local Storage (TLS) 
\cite{migrate-to-shared}. 
If resources are to be shared between different threads, D provides a way of 
achieving this: the \texttt{shared} and
\texttt{\textunderscore{}\textunderscore{}gshared} keywords.
\par\bigskip\noindent
The core runtime for D provides an additional interesting feature: an atomicop 
library 
\cite{core-atomic}. 
This provides a mechanism for some degree of sharing to be performed without the 
need for locks, allowing many operations to be performed indivisibly.

\subsection{Memory Safe Programming}
% Concept of memory safe programming that D supports.
An area of particular interest to real-time systems is the notion of memory 
safe programming. In addition to providing powerful inbuilt types such as arrays 
in D, the D compiler also implements range checking and numerous other 
safety checks on compilation, preventing any undefined behaviour from occurring.
Additional safety features are also provided in the SafeD subset of the language
\cite{safe-d}. The SafeD subset will only allow functions to perform 
operations that are deemed as either safe or trusted, preventing any 
potential corruption of memory. Examples of unsafe functions could include the 
manual manipulation of pointers, or the use of unsafe types. A major difference 
with regards to other languages is that D provides sufficient power so that many complex 
operations can be performed and used, while still remaining completely safe.

\subsection{Garbage Collector}
%GC
Coupled with the safety of the SafeD subset, D provides additional memory
safety through its use of a garbage collector. A garbage collector
automatically manages heap allocated memory. It is responsible for managing
the lifetime of data, and cleaning up unused memory. 
However, this safety comes at a cost. One significant problem with developing a 
real-time system in D is the need to bypass D's garbage collector. 
The current implementation of the garbage 
collector is a `stop the world' approach: when garbage collection is occurring, 
all threads are halted from making progress 
\cite{dlang-garbage}. This causes problems with 
real-time systems. A real-time system must be able to guarantee a maximum response 
time on any operation performed, predictable behaviour is therefore fundamental to this. 
With a stop the world garbage collector, such behaviour cannot be guaranteed. 
\par\bigskip\noindent
One possible solution to this problem is to disable the garbage collector for 
real time applications. This is possible to do by marking functions \texttt{@nogc}, 
or by calling \texttt{GC.disable()}. However, this is not without drawbacks: 
many of D's higher level features and libraries use garbage collection. 
%TODO - An alternative approach, i.e detaching a thread from the runtime
Another possibility is to replace D's garbage collector with a real-time 
garbage collector. This would provide predictable behaviour, and therefore
would enable precise timing requirements to be met.
However, due to the amount of further work required, tackling the issue of the garbage 
collector is outside the scope of this article.

\subsection{Additional Interesting Features}
% Idea of built in tests, contract programming, debugging, error handling
Another unique feature of D is the ability to build unit tests into a 
program without the need for external libraries: D provides support for 
unittesting as a language feature. 
\par\bigskip\noindent
In addition, D provides a Java style model for Exceptions and Errors, enabling 
a much simpler error handling system than the C style ERRNOs 
\cite{ddili-book}. 
%TODO - Compare with C++ exceptions. Possibly Java exceptions too. 


\section{Target Criteria}

\subsection{Concurrency}

\subsection{Monotonic Clocks}

\subsection{Priority Scheduling}

\subsection{Bounded Priority Inversion}

\subsection{Asynchronous Transfer of Control}
