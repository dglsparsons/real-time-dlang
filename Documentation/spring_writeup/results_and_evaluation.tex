% Results and Evaluation Section of the Writeup 

% Word Count Guide - 2500 Words
This section sets out to examine the provided library, and how its usage
compares syntactically to the development of a real-time system in Ada. 
Following on from
this, a comparison in terms of efficiency will be made with Ada. Furthermore,
the efficiency of the two implementations of Asynchronous Transfer of Control in 
D will be examined. 

% Appreciate the latent issues of the subject area (for example, 
% in software engineering they might meet and tackle such as emergent requirements, 
% design flaws, equipment/application problems). Examined in the project 
% design/implementation and evaluation chapters. 
\section{Comparison with Ada}

This section sets to compare the implementation of real-time primitives in D,
with those of Ada, a general purpose programming language with a wide range of
support for real-time systems. The syntax of the two languages is significantly 
different: D follows a C style approach, using curly braces to indicate scope,
Ada by contrast follows a Pascal style syntax, using \texttt{begin} and
\texttt{end} statements to indicate scope. However, despite these differences,
the two languages have much in common. 

\subsection{Concurrency}

In Ada, it is possible to separate a concurrent thread of control through the
medium of a task. This enables a level of parallelism. A \texttt{Task} can be 
created in the following manner: 
%TC:ignore
\begin{lstlisting}[language=Ada]
procedure Program is 
    task My_Task; 

    task body My_Task is 
    begin
        ...
    end My_Task;

begin
    null; 
end Program;
\end{lstlisting}
%TC:endignore
It is worth noting than in the above example, the \texttt{Program} procedure will wait
for \texttt{My\textunderscore{}Task} to complete before exiting. D differs in this aspect: 
there is no concept of ownership of a \texttt{Thread}, and unless
explicitly stated through \texttt{Thread.join}, a process will not await
\texttt{Thread} completion. The notable exception to this is exiting the
\texttt{main} function, which waits for all threads to terminate. 
In terms of syntax, the creation of a
\texttt{Thread} in D is similarly different. Rather than specifying the body of
the task inline, it is more typical to place it in a separate function. This
appears as follows: 
%TC:ignore
\begin{lstlisting}
import core.thread; 

void threadFunction()
{
    ...
}

void main()
{
    new Thread(&threadFunction).start;
}
\end{lstlisting}
%TC:endignore
Thus, both languages are able to similarly specify concurrent computation. In
Ada, this is achieved through the medium of a \texttt{Task}, in D, the medium
is provided by a \texttt{Thread}. 

\subsection{Priority Scheduling}
Important to real-time systems is the concept of priority scheduling. In both
Ada and D priority based scheduling is implemented. In Ada, the systems scheduler can
be set through the use of a \texttt{pragma}. This is done as follows: 
%TC:ignore
\begin{lstlisting}[language=Ada]
pragma task_dispatching_policy(fifo_within_priorities); 
\end{lstlisting}
%TC:endignore
This allows the priority of a task to be statically set in the following manner: 
%TC:ignore
\begin{lstlisting}[language=Ada]
task Worker is 
    pragma Priority(System.Priority'First + 1); 
end Worker;

task body Worker is 
begin 
    ...
end Worker; 
\end{lstlisting}
%TC:endignore
Priority scheduling behaves in a similar manner in D, however, there is one
fundamental difference: the standard approach to priorities in D is not static, 
and any priorities must instead be assigned at runtime. 
Furthermore, priorities can be changed during the programs execution. While similar
behaviour can be implemented in Ada using the
\texttt{Ada.Dynamic\textunderscore{}Priorities}
package, it is the only option for priority scheduling in D. 
Priority scheduling can thus be achieved in the following manner: 
%TC:ignore 
\begin{lstlisting}
import core.thread; 

void threadFunction()
{
    ...
}

void main()
{
    setFIFOScheduler(Thread.PRIORITY_MAX);
    auto a = new Thread(&threadFunction).start;
    a.priority = Thread.PRIORITY_MIN + 1; 
    Thread.sleep(2.seconds); 
    a.priority = Thread.PRIORITY_MIN + 5; 
}
\end{lstlisting}
%TC:endignore
This example shows not only an initial assignment of a priority to a created
\texttt{Thread}, but highlights the possibility of modifying a priority at
runtime. 

\subsection{Shared Memory}
With all multithreaded programs, communication between different concurrent
components is crucial. Both Ada and D support the notion of shared memory,
allowing separate \texttt{Threads} or \texttt{Tasks} to access the same
variables. However, due to D's use of shared memory, shared memory functions
differently. In D, each \texttt{Thread} contains its own copy of a global 
variables unless the variable is stated 
as \texttt{shared} or \texttt{\textunderscore{}\textunderscore{}gshared}. 
\par\bigskip\noindent
In Ada, it is common practice to use protected objects to read and write to
variables, preventing inconsistency. These operate by defining several different 
operation types: a function that allows concurrent reads to occur; a procedure
is exclusive of other procedures and functions and allows writes to occur; 
and an entry allows a task to block, waiting on a condition. This is shown
below: 
%TC:ignore
\begin{lstlisting}[language=Ada]
protected Read_Write is
    function Read return Integer;
    procedure Write(New_Value : in Integer); 
private 
    Data : Integer := 0; 
end Read_Write;

protected body Read_Write is 
begin 
    function Read is 
    body 
        return Data; 
    end Read; 

    procedure Write(New_Value: in Integer) is 
    body
        Data := New_Value; 
    end Write; 
end Read_Write; 
\end{lstlisting}
%TC:endignore
D does not provide the notion of protected objects, but instead uses a
special \texttt{ReadWriteMutex} that emulates this behaviour.
Using this, the previous Ada code may be rewritten in D
in the following manner: 
%TC:ignore
\begin{lstlisting}
auto mut = new ReadWriteMutex(); 
int data = 0; 
void readerFunction()
{
    synchronized(mut.reader)
    {
        return data; 
    }
}

void writerFunction(int newValue)
{
    synchronized(mut.writer)
    {
        data = newValue;
    }
}
\end{lstlisting}
%TC:endignore
This allows the same principle, protected data, to be used in D for
safe interprocess communication using shared memory. However, the ability to 
define an \texttt{entry} or a \texttt{requeue} is not encapsulated. In D,
however, it is 
possible to use the \texttt{Condition} class to simulate entry behaviour 
\cite{dlang-condition}. 
It is worth noting that when using \texttt{ReadWriteMutex}, it is not possible to 
use either the priority ceiling or priority inheritance protocol.
However, this can be implemented: the \texttt{ReadWriteMutex} class
can be redefined as using the corresponding \texttt{CeilingMutex} or
\texttt{InheritanceMutex} classes, rather than a \texttt{Mutex}. 

\subsection{Priority Inheritance and Priority Ceiling Protocols}
As detailed in the Literature Review, the ability to use either the priority
inheritance protocol, or the priority ceiling protocol is crucial in order to
provide a bounded limit on the about of priority inversion that a task can
suffer. Ada supports use of the priority ceiling protocol in the following
manner: 
%TC:ignore 
\begin{lstlisting}[language=Ada]
protected Buffer is 
    pragma Priority(28); 
    ...
end Buffer; 
\end{lstlisting}
%TC:endignore
When accessing the Buffer, an accessing \texttt{Task} has it's priority raised
to 28. In D the same functionality is implemented. In D, this only applies to
the \texttt{CeilingMutex} though: any \texttt{Thread} that holds a lock on a
\texttt{CeilingMutex} has its priority raised. This appears in the following
manner: 
%TC:ignore 
\begin{lstlisting}
import realtime; 

auto ceilingMutex = new CeilingMutex(); 

void accessResource()
{
    synchronized(ceilingMutex)
    {
        ...
    }
}

void main()
{
    ceilingMutex.ceiling = 28; 
    ...
}
\end{lstlisting}
%TC:endignore

\subsection{Periodic Tasks}
For a real-time system, periodic tasks are a common feature. In Ada, a periodic
task is defined in the following manner: 
%TC:ignore 
\begin{lstlisting}[language=Ada]
task Periodic; 
task Periodic is 
    Release_Interval : Time_Span := Milliseconds(100); 
    Next_Release : Time := Clock + Release_Interval; 
begin
    loop 
        delay until Next_Release; 
        ... 
        Next_Release := Next_Release + Release_Interval; 
    end loop; 
end Periodic; 
\end{lstlisting}
%TC:endignore
This can be defined almost identically in D: 
%TC:ignore
\begin{lstlisting}
void periodic()
{
    immutable releaseInterval = 100.msecs; 
    auto nextRelease = MonoTime.currTime + releaseInterval; 
    while(true)
    {
        delayUntil(nextRelease); 
        ...
        nextRelease += releaseInterval; 
    }
}

void main()
{
    new Thread(&periodic).start; 
    ...
}
\end{lstlisting}
%TC:endignore
This therefore allows a periodic task to be defined in a manner very
similar to that of Ada. There is little visible difference between the two
implemnentations.

\subsection{Sporadic Tasks}


\subsection{Asynchronous Transfer of Control}


\section{Efficiency of Asynchronous compared to Ada}
% Compare D with Ada in terms of efficiency.
In order to form a true comparison between the two languages, D and Ada, it is
necessary to examine their performance.

\section{Comparison of Asynchronous Transfer of Control Approaches in D}
% Profile the two ATC Methods. 
