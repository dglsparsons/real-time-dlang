% Results and Evaluation Section of the Writeup 

% Word Count Guide - 2500 Words
This section sets out to examine the provided library, and how its usage
compares syntactically to the development of a real-time system in Ada. 
Following on from
this, a comparison in terms of efficiency will be made with Ada. Furthermore,
the efficiency of the two implementations of Asynchronous Transfer of Control in 
D will be examined. 

% Appreciate the latent issues of the subject area (for example, 
% in software engineering they might meet and tackle such as emergent requirements, 
% design flaws, equipment/application problems). Examined in the project 
% design/implementation and evaluation chapters. 
\section{Comparison with Ada}

This section sets to compare the implementation of real-time primitives in D,
with those of Ada, a general purpose programming language with a wide range of
support for real-time systems. The syntax of the two languages is significantly 
different: D follows a C style approach, using curly braces to indicate scope,
Ada by contrast follows a Pascal style syntax, using \texttt{begin} and
\texttt{end} statements to indicate scope. However, despite these differences,
the two languages have much in common. 

\subsection{Concurrency}

In Ada, it is possible to separate a concurrent thread of control through the
medium of a task. This enables a level of parallelism. A \texttt{Task} can be 
created in the following manner: 
%TC:ignore
\begin{lstlisting}[basicstyle=\small,language=Ada]
procedure Program is 
    task My_Task; 

    task body My_Task is 
    begin
        ...
    end My_Task;

begin
    null; 
end Program;
\end{lstlisting}
%TC:endignore
It is worth noting than in the above example, the \texttt{Program} procedure will wait
for \texttt{My\textunderscore{}Task} to complete before exiting. D differs in this aspect: 
there is no concept of ownership of a \texttt{Thread}, and unless
explicitly stated through \texttt{Thread.join}, a process will not await
\texttt{Thread} completion. The notable exception to this is exiting the
\texttt{main} function, which waits for all threads to terminate. 
In terms of syntax, the creation of a
\texttt{Thread} in D is similarly different. Rather than specifying the body of
the task inline, it is more typical to place it in a separate function. This
appears as follows: 
%TC:ignore
\begin{lstlisting}[basicstyle=\small]
import core.thread; 

void threadFunction()
{
    ...
}

void main()
{
    new Thread(&threadFunction).start;
}
\end{lstlisting}
%TC:endignore
Thus, both languages are able to similarly specify concurrent computation. In
Ada, this is achieved through the medium of a \texttt{Task}, in D, the medium
is provided by a \texttt{Thread}. 

\subsection{Priority Scheduling}
Important to real-time systems is the concept of priority scheduling. In both
Ada and D priority based scheduling is implemented. In Ada, the systems scheduler can
be set through the use of a \texttt{pragma}. This is done as follows: 
%TC:ignore
\begin{lstlisting}[basicstyle=\small,language=Ada]
pragma task_dispatching_policy(fifo_within_priorities); 
\end{lstlisting}
%TC:endignore
This allows the priority of a task to be statically set in the following manner: 
%TC:ignore
\begin{lstlisting}[basicstyle=\small,language=Ada]
task Worker is 
    pragma Priority(System.Priority'First + 1); 
end Worker;

task body Worker is 
begin 
    ...
end Worker; 
\end{lstlisting}
%TC:endignore
Priority scheduling behaves in a similar manner in D, however, there is one
fundamental difference: the standard approach to priorities in D is not static, 
and any priorities must instead be assigned at runtime. 
Furthermore, priorities can be changed during the programs execution. While similar
behaviour can be implemented in Ada using the
\texttt{Ada.Dynamic\textunderscore{}Priorities}
package, it is the only option for priority scheduling in D. 
Priority scheduling can thus be achieved in the following manner: 
%TC:ignore 
\begin{lstlisting}[basicstyle=\small]
import core.thread; 

void threadFunction()
{
    ...
}

void main()
{
    setFIFOScheduler(Thread.PRIORITY_MAX);
    auto a = new Thread(&threadFunction).start;
    a.priority = Thread.PRIORITY_MIN + 1; 
    Thread.sleep(2.seconds); 
    a.priority = Thread.PRIORITY_MIN + 5; 
}
\end{lstlisting}
%TC:endignore
This example shows not only an initial assignment of a priority to a created
\texttt{Thread}, but highlights the possibility of modifying a priority at
runtime. 

\subsection{Shared Memory}
With all multithreaded programs, communication between different concurrent
components is crucial. Both Ada and D support the notion of shared memory,
allowing separate \texttt{Threads} or \texttt{Tasks} to access the same
variables. However, due to D's use of shared memory, shared memory functions
differently. In D, each \texttt{Thread} contains its own copy of a global 
variables unless the variable is stated 
as \texttt{shared} or \texttt{\textunderscore{}\textunderscore{}gshared}. 
\par\bigskip\noindent
In Ada, it is common practice to use protected objects to read and write to
variables, preventing inconsistency. These operate by defining several different 
operation types: a function that allows concurrent reads to occur; a procedure
is exclusive of other procedures and functions and allows writes to occur; 
and an entry allows a task to block, waiting on a condition. This is shown
below: 
%TC:ignore
\begin{lstlisting}[basicstyle=\small,language=Ada]
protected Read_Write is
    function Read return Integer;
    procedure Write(New_Value : in Integer); 
private 
    Data : Integer := 0; 
end Read_Write;

protected body Read_Write is 
begin 
    function Read is 
    body 
        return Data; 
    end Read; 

    procedure Write(New_Value: in Integer) is 
    body
        Data := New_Value; 
    end Write; 
end Read_Write; 
\end{lstlisting}
%TC:endignore
D does not provide the notion of protected objects, but instead uses a
special \texttt{ReadWriteMutex} that emulates this behaviour.
Using this, the previous Ada code may be rewritten in D
in the following manner: 
%TC:ignore
\begin{lstlisting}[basicstyle=\small]
auto mut = new ReadWriteMutex(); 
int data = 0; 
void readerFunction()
{
    synchronized(mut.reader)
    {
        return data; 
    }
}

void writerFunction(int newValue)
{
    synchronized(mut.writer)
    {
        data = newValue;
    }
}
\end{lstlisting}
%TC:endignore
This allows the same principle, protected data, to be used in D for
safe interprocess communication using shared memory. However, the ability to 
define an \texttt{entry} or a \texttt{requeue} is not encapsulated. In D,
however, it is 
possible to use the \texttt{Condition} class to simulate entry behaviour 
\cite{dlang-condition}. 
It is worth noting that when using \texttt{ReadWriteMutex}, it is not possible to 
use either the priority ceiling or priority inheritance protocol.
However, this can be implemented: the \texttt{ReadWriteMutex} class
can be redefined as using the corresponding \texttt{CeilingMutex} or
\texttt{InheritanceMutex} classes, rather than a \texttt{Mutex}. 

\subsection{Priority Inheritance and Priority Ceiling Protocols}
As detailed in the Literature Review, the ability to use either the priority
inheritance protocol, or the priority ceiling protocol is crucial in order to
provide a bounded limit on the about of priority inversion that a task can
suffer. Ada supports use of the priority ceiling protocol in the following
manner: 
%TC:ignore 
\begin{lstlisting}[basicstyle=\small,language=Ada]
protected Buffer is 
    pragma Priority(28); 
    procedure accessResource; 
    ...
end Buffer; 
\end{lstlisting}
%TC:endignore
When accessing the Buffer, an accessing \texttt{Task} has it's priority raised
to 28. In D the same functionality is implemented. In D, this applies to
the \texttt{CeilingMutex}: any \texttt{Thread} that holds a lock on a
\texttt{CeilingMutex} has its priority raised. This appears in the following
manner: 
%TC:ignore 
\begin{lstlisting}[basicstyle=\small]
auto mut = new CeilingMutex(28); 

void accessResource()
{
    synchronized(mut)
    {
        ...
    }
}
\end{lstlisting}
%TC:endignore
As with the implementation in Ada, the ceiling property is dynamic, and can be
adjusted at runtime. It is therefore possible to see that both D, through this
project, provides the priority ceiling protocol. However, the priority
inheritance protocol is also introduced to D. This is absent from Ada, and can
be used in the following manner: 
%TC:ignore
\begin{lstlisting}[basicstyle=\small]
auto mut = new InheritanceMutex; 

void accessResource()
{
    synchronized(mut)
    {

    }
}
\end{lstlisting}
%TC:endignore
Through these examples, it is shown that D provides two alternative protocols
to solve priority inversion: the priority ceiling protocol, which behaves the
same as Ada's priority ceiling protocol, and the priority inheritance protocol. 

\subsection{Periodic Tasks}
For a real-time system, periodic tasks are a common feature. In Ada, a periodic
task is defined in the following manner: 
%TC:ignore 
\begin{lstlisting}[basicstyle=\small,language=Ada]
task Periodic; 
task Periodic is 
    Release_Interval : Time_Span := Milliseconds(100); 
    Next_Release : Time := Clock + Release_Interval; 
begin
    loop 
        delay until Next_Release; 
        ... 
        Next_Release := Next_Release + Release_Interval; 
    end loop; 
end Periodic; 
\end{lstlisting}
%TC:endignore
This can be defined almost identically in D using the provided
\texttt{delayUntil} function: 
%TC:ignore
\begin{lstlisting}[basicstyle=\small][language=Java]
void periodic()
{
    immutable releaseInterval = 100.msecs; 
    auto nextRelease = MonoTime.currTime + releaseInterval; 
    while(true)
    {
        delayUntil(nextRelease); 
        ...
        nextRelease += releaseInterval; 
    }
}

void main()
{
    new Thread(&periodic).start; 
    ...
}
\end{lstlisting}
%TC:endignore
This therefore allows a periodic task to be defined in a manner very
similar to that of Ada. There is little visible difference between the two
implementations, and as both utilise operating system threads, there is little
difference in overhead between the two languages. 

\subsection{Asynchronous Transfer of Control}
Another crucial aspect of a real-time system is the ability to perform
Asynchronous Transfer of Control (ATC). In Ada, this is achieved with a special
variation of the \texttt{select} statement: the \texttt{select ... then abort}
statement. For example, a timeout of 2 seconds on a function call takes the 
following form: 
%TC:ignore 
\begin{lstlisting}[basicstyle=\small,language=Ada]
select 
    delay 2.0; 
    -- cleanup goes here 
then abort
    abortable_function; 
end select; 
\end{lstlisting}
%TC:endignore
In D, it is not possible to program a timeout in this manner: the method of ATC
is fundamentally very different, taking instead a class based approach using 
signals. In D, an \texttt{Interruptible} task is defined. This enables
execution of a function to be performed until there is a call to
\texttt{interrupt}. Therefore, programming a timeout in D requires an additional
thread to be created compared to the Ada implementation. This may appear as follows: 
%TC:ignore
\begin{lstlisting}[basicstyle=\small]
void abortableFunction()
{
    ...
}

void main()
{
    Interruptible intr = new Interruptible(&abortableFunction); 
    new Thread({
        Thread.sleep(2.seconds); 
        intr.interrupt(); 
    }).start;
    intr.start; 
}
\end{lstlisting}
%TC:endignore
This allows a implementation of ATC in D, sharing many similarities with the
behaviour of Ada. However, in some regards it is subtly different to 
Ada's model of ATC. The most significant difference is the management of
whether a section of code is abort deferred or not. In Ada, there is notion of
a task being abort-deferred, specified by \texttt{pragma Abort\textunderscore{}Defer}
\cite{atc-article}.
This prevents asynchronous cancellation for
critical regions of code, so that they may safely perform operations such as
updating shared memory or allocating memory. 
For most standard interactions, such as with protected objects or standard
packages, there is no need to explicitly specify code as abort-deferred. This
therefore removes the concern from the developer. In D, there is no notion of a
function being abort-deferred. Instead, it is left up to the developer to
control whether an ATC region of code may have interrupts deferred, using the 
\texttt{Interruptible.getThis.deferred} flag. This manual management of
abort-deferred regions of code requires careful management for the developer. 

\section{Comparison of Asynchronous Transfer of Control Approaches in D}
% Profile the two ATC Methods. 
Two alternative approaches to providing asynchronous transfer of control
have been implemented in D. In this section, both of these implementations will 
be profiled, comparing the performance benefits of a one thread, exception approach over a 
two thread model. 
\par\bigskip\noindent
For profiling, a sample program was created that records the
time taken for both the setup of an \texttt{Interruptible} section, and the time 
taken to progress from receiving an asynchronous \texttt{interrupt}. In order to 
provide reliable results,
this was repeated 10,000 times with average times recorded. Furthermore, both
the \texttt{Thread} model, and the \texttt{Exception} model have been compiled 
using the same version of the DMD compiler (2.069.2), with no compiler
optimisation. This was run on a Linux system at a high
priority (90) in order to minimise the amount of interference that the
profiling might suffer. 
The D code for profiling the Exception based ATC is as follows: 
\lstinputlisting[language=C++]{exception_profile.d}
Similarly, Thread based ATC is profiled using the following code: 
\lstinputlisting[language=C++]{thread_profile.d}
These tests produced the following results for the setup and cancellation times: 
\begin{table}[!htbp]
\begin{tabular}{l|lll}
ATC Method & Average Setup Time & Cancellation Time  & Total          \\
           & (microseconds)     & (microseconds)     & (microseconds) \\ \hline
Threaded   & 37.81              & 34.40              & 72.21          \\
Exception  & 13.95              & 13.18              & 27.13          \\
\end{tabular}
\end{table} \\
% Ada times & 1.11              & 69.11          & 70.22  \\ 
As expected, this shows that there is an additional overhead in the
\texttt{Thread} based approach to ATC compared to an \texttt{Exception} based
approach: creating a new \texttt{Thread} for each
invocation has a more significant overhead, leading to around a 260\% increase 
in setup time. This occurs as the creation of a \texttt{Thread} in D involves
the creation of a kernel thread, requiring many operating system calls.
Furthermore, the \texttt{Thread} based approach also takes longer to perform
the cancellation. Both approaches use a POSIX signal in order to asynchronously
perform their cancellation: the \texttt{Exception} based approach uses a signal
to throw an exception and the \texttt{Thread} based approach uses a signal to
terminate the Thread. However, with the \texttt{Thread} based approach, the
application must wait for the \texttt{Thread} to be fully completed before it can
continue. This is a lengthier process than simply catching an
\texttt{Exception}, as resources must be reclaimed and any \texttt{Thread}
cleanup executed. 

\section{Efficiency of Asynchronous compared to Ada}
% Compare D with Ada in terms of efficiency.
In addition to comparing the two Asynchronous Transfer of Control mechanisms, a
comparison against Ada can be used to highlight the performance of D. As in the
previous example, it is possible to profile both the setup time and cancellation
time of Ada's ATC method in a similar manner to that of D. This takes the
following form: 
\lstinputlisting[language=Ada]{./ada_profile.adb}
A profiling of the Ada implementation of Asynchronous Transfer of Control gives
the following results: 
\begin{table}[!htbp]
\begin{tabular}{l|lll}
ATC Method & Average Setup Time & Cancellation Time  & Total          \\
           & (microseconds)     & (microseconds)     & (microseconds) \\ \hline
D Threaded &  37.81             & 34.40              & 72.21          \\
D Exception & 13.95             & 13.18              & 27.13          \\
Ada         &  1.11             & 69.11              & 70.22          \\
\end{tabular}
\end{table} \\
This shows a different distribution of setup and cancellation times compared to
the previous D profiles: 
-- TODO - check with Andy whether this is right. 
